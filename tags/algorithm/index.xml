<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>algorithm on 林三木的博客</title><link>https://linjiasen63.github.io/tags/algorithm.html</link><description>Recent content in algorithm on 林三木的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 29 May 2021 16:05:09 +0000</lastBuildDate><atom:link href="https://linjiasen63.github.io/tags/algorithm/index.xml" rel="self" type="application/rss+xml"/><item><title>数据结构与算法：求二叉树的最小深度</title><link>https://linjiasen63.github.io/posts/programming/algorithm/min-depth-of-binary-tree.html</link><pubDate>Sat, 29 May 2021 16:05:09 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/algorithm/min-depth-of-binary-tree.html</guid><description>1. 二叉树的最小深度 graph TD 1(1) --&amp;gt; 2(2) 1(1) --&amp;gt; 3(3) 2(2) --&amp;gt; 4(4) 2(2) --&amp;gt; 5(5) 3(3) --&amp;gt; 6(6) 6(6) --&amp;gt; 7(7) 6(6) --&amp;gt; 8(8) 2. 具体实现 function TreeNode(value, left, right) { this.value = value this.left = left this.right = right } const node8 = new TreeNode(8, null, null) const node7 = new TreeNode(7, null, null) const node6 = new TreeNode(6, node7, node8) const node5 = new TreeNode(5, null, null) const node4 = new TreeNode(4, null, null) const node3 = new TreeNode(3, node6, null) const node2 = new TreeNode(2, node4, node5) const node1 = new TreeNode(1, node2, node3) 2.1 深度优先DFS 从叶子节点向根节点查找，取节点的左、右子点树深度较小的值，然后递归直到根结点。实际求解中，还是从根结点开始计算，只是递归求解子节点的最小深度。</description></item><item><title>数据结构与算法：常见的排序算法</title><link>https://linjiasen63.github.io/posts/programming/algorithm/sort-algorithm.html</link><pubDate>Thu, 25 Mar 2021 16:38:44 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/algorithm/sort-algorithm.html</guid><description>1. 冒泡排序 bubbleSort
时间复杂度：O(n^2)
function sort(arr) { for (let i = 0; i &amp;lt; arr.length; i++) { for (let j = 0; j &amp;lt; arr.length - 1 - i; j++) { if (arr[j] &amp;gt; arr[j + 1]) { const tmp = arr[j + 1]; arr[j + 1] = arr[j]; arr[j] = tmp; } } } } const arr = [10, 9, 22, -2, -4, 9]; console.log(&amp;#34;排序前：&amp;#34;, arr); sort(arr); console.log(&amp;#34;排序后：&amp;#34;, arr); 2. 选择排序 selectSort
时间复杂度：O(n^2)
function sort(arr) { for (let i = 0; i &amp;lt; arr.length; i++) { let index = i; for (let j = i + 1; j &amp;lt; arr.</description></item><item><title>数据结构与算法：初识</title><link>https://linjiasen63.github.io/posts/programming/algorithm/tutorial-basic.html</link><pubDate>Mon, 15 Mar 2021 14:13:45 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/algorithm/tutorial-basic.html</guid><description>1. 数据结构与算法 1.1 数据结构 数据结构按照存储方式进行分类，如下所示：
逻辑结构：数据存储在虚拟逻辑的方式； 集合 线性 树型 图型 物理结构：数据存储在物理介质的方式； 物理介质有硬盘、内存等 按照逻辑结构与物理结构的异同
顺序存储结构：逻辑结构与物理结构一致 链式存储结构：逻辑结构与物理结构不同 1.2 算法 算法设计的基本准则
确定性 可行性 可读性 健壮性 算法效率的评估方式
时间效率 存储容量 时间算法 名称 O(1) 常数 O(n) 线性 O(log(2)n) 对数 O(nlog(2)n) nlog(2)n O(n^2) 平方 O(n^3) 立方 对数时间复杂度的代码示例以及计算过程 function calc(n) { let i = 1; while(i * 2 &amp;lt;= n) { /*执行操作*/ } } // 执行次数：2^x = n，即：x=log(2)N 2. 线性表 2.1 数组 时间复杂度
查询（retireve）：O(1) 更新（update）：O(1) 插入（insert）：O(n) 删除（delete）：O(n) 2.</description></item></channel></rss>
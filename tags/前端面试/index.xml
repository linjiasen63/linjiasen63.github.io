<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>前端面试 on 林三木的博客</title><link>https://linjiasen63.github.io/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95.html</link><description>Recent content in 前端面试 on 林三木的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 11 Jan 2021 17:22:19 +0000</lastBuildDate><atom:link href="https://linjiasen63.github.io/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/index.xml" rel="self" type="application/rss+xml"/><item><title>前端面试系列：样式相关</title><link>https://linjiasen63.github.io/posts/programming/front/interview/style.html</link><pubDate>Mon, 11 Jan 2021 17:22:19 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/interview/style.html</guid><description>1. 以下代码中left与right的宽度分别是？ &amp;lt;div class=&amp;#34;container&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;left&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;right&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;style&amp;gt; .container { display: flex; width: 600px; height: 40px; } .left { flex-grow: 1; flex-shrink: 2; flex-basis: 500px; background: #2bff00; } .right { flex-grow: 2; flex-shrink: 1; flex-basis: 400px; background: #4396e2; } &amp;lt;/style&amp;gt; 计算规则：
若超过容器的宽度
子元素的位权：${shrink的比重} * ${原始宽度：如width或basis指定的} 子元素位权比：子元素位权 / 所有子元素位权之和 子元素的宽度：原始宽度 - 子元素位权比 * 超过的容器的宽度 即： 超出容器宽度：500 + 400 - 600 = 300 left的位重为：2 * 500 = 1000 left + right的位重和为： 2 * 500 + 1 * 400 = 1400 left的宽度：500 - 1000/1400*300 = 285.72 若容器有多余宽度
容器多余宽度：容器的宽度 - 子元素原始宽度之和 子元素位重比：子元素位重grow / 所有子元素位重grow之和 子元素的宽度：子元素原始宽度 + 子元素位重比 * 容器多余宽度 将上述题目中的css修改为：` flex-basis: initial;` 即： 超出容器宽度：600 - 0 = 600 left的位重比为：1 / (1 + 2) = 1/3 left的宽度：0 + 600*1/3 = 200 将上述题目中的css修改为：` flex-basis: 100px;` 即： 超出容器宽度：600 - 200 = 400 left的位重比为：1 / (1 + 2) = 1/3 left的宽度：200 + 400*1/3 = 233.</description></item><item><title>前端面试系列：手写常见方法</title><link>https://linjiasen63.github.io/posts/programming/front/interview/coding-fn.html</link><pubDate>Wed, 30 Dec 2020 15:10:42 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/interview/coding-fn.html</guid><description>1. new 原生实现：new Fn(...args)；自定义实现：newSelf(Fn, ...args)；
实现步骤：
校验传入的参数（Fn，args）（通过Array.prototype.slice获取） 创建空对象obj 将obj.__proto__赋值为Fn.prototype，obj.constructor赋值为Fn 将obj作为上下文，执行Fn 如果Fn有返回值result，则返回result；否则返回对象obj function newSelf() { var fn = Array.prototype.shift.call(arguments); if (typeof fn != &amp;#39;function&amp;#39;) { throw new Error(&amp;#34;The first param of the newSelf must be a function!&amp;#34;); } var obj = {}; obj.__proto__ = fn.prototype; obj.constructor = fn; var result = fn.apply(obj, arguments); return typeof result === &amp;#39;object&amp;#39; ? result : obj; } function Person(name) { this.name = name; } // test case var p = newSelf(Person, &amp;#39;小红&amp;#39;); console.log(&amp;#39;person str: &amp;#39;, p); console.log(&amp;#39;instanceof: &amp;#39;, p instanceof Person); 2. instanceof 原生实现：left instanceof right；自定义实现：instanceOfSelf(left, right)
实现步骤：
校验参数：left以及right 的合法性 获取obj=left.__proto; proto=right.prototype; 若obj为null，则返回false; 若obj===proto为ture，则返回true; 否则obj赋值为obj.</description></item><item><title>前端面试系列：浏览器输入url到网页展示期间发生了什么？</title><link>https://linjiasen63.github.io/posts/programming/front/interview/things-about-from-url-to-html.html</link><pubDate>Tue, 29 Dec 2020 14:42:56 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/interview/things-about-from-url-to-html.html</guid><description>1. 概要流程 DNS查找，确定ip 三次握手，建立链接 客户端发送请求 服务端返回响应 四次挥手，销毁链接 浏览器解析内容 2. 详细解释 2.1 DNS查找，确定IP 2.1.1 概述 逐一向“浏览器”、“操作系统”、“路由器”询问：是否知道ip地址？若知道则返回； 从本地系统向本地DNS服务器（电脑上网络配置中的dns，如8.8.8.8）发起迭代询问； 2.1.2 详情 查询IP（有两种方式，一般使用以下方式，减少根服务器的压力）
方式一：
1. “操作系统” -&amp;gt; “本地DNS服务器”查询 2. “本地DNS服务器” -&amp;gt; “根域名服务器”（ipv4，全球只有13个） 3. “本地DNS服务器” -&amp;gt; “顶级域名服务器” 1. 通用：如com、edu等 2. 地区：如cn、jp、等 3. 特殊：如 4. “本地DNS服务器” -&amp;gt; “权威域名服务器”（饲服务器） 方式二：（现实中几乎不会使用到）
1. “操作系统” -&amp;gt; “本地DNS服务器”查询 2. “本地DNS服务器” -&amp;gt; “根域名服务器” 3. “根域名服务器” -&amp;gt; “顶级域名服务器” 4. “顶级域名服务器” -&amp;gt; “权威域名服务器” 5. 然后把结果逐一返回 2.2 三次握手，建立链接 client发起建立连接，发送同步序列号：随机生成的x（本次发送信息开始的编号，以后逐次+1）； sever收到client内容，返回client下次的同步序列号为（x+1，因为已发送了一个包），然后生成server对应的同步序列号y； clent收到server内容，发送确认包（server下次的同步序列号为y+1）； sequenceDiagram Client -&amp;gt;&amp;gt; Server: SYN=1，seq=x（x是随机生成的） Server -&amp;gt;&amp;gt; Client: ACK=1, ack=x+1；SYN=1，seq=y（y是随机生成的） Client -&amp;gt;&amp;gt; Server: ACK=1，ack=y+1 为什么是三次握手而不是二次？原因：保证连接是尽量可靠的。
2.3 客户端发送请求 // 请求行 HTTP/1.1 baidu.com GET // 首部字段 Content-Type: text/html; charset=utf-8 // 请求体 2.</description></item></channel></rss>
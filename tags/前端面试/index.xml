<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>前端面试 on 林三木的博客</title><link>https://linjiasen63.github.io/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95.html</link><description>Recent content in 前端面试 on 林三木的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 03 Mar 2021 15:36:59 +0000</lastBuildDate><atom:link href="https://linjiasen63.github.io/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/index.xml" rel="self" type="application/rss+xml"/><item><title>前端系列： JS 错误监控</title><link>https://linjiasen63.github.io/posts/programming/front/logic/error-monitor.html</link><pubDate>Wed, 03 Mar 2021 15:36:59 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/logic/error-monitor.html</guid><description>参考：
onerror的MDN介绍 window.onerror的总结 1. 主要内容 window.onerror = function(message, source, lineno, colno, error) { ... } // 函数参数： // message：错误信息（字符串）。可用于HTML onerror=&amp;#34;&amp;#34;处理程序中的event。 // source：发生错误的脚本URL（字符串） // lineno：发生错误的行号（数字） // colno：发生错误的列号（数字） // error：Error对象（对象） // 若该函数返回true，则阻止执行默认事件处理函数。 2. 注意事项 当加载自不同域的脚本中发生语法错误时，为避免信息泄露，语法错误的细节将不会报告，而代之简单的&amp;quot;Script error.&amp;quot;。在某些浏览器中，通过在&amp;lt;script&amp;gt;使用crossorigin属性并要求服务器发送适当的 CORS HTTP 响应头（Access-Control-Allow-Origin: *），该行为可被覆盖。</description></item><item><title>前端系列：script标签的defer、async属性</title><link>https://linjiasen63.github.io/posts/programming/front/layout/label-script.html</link><pubDate>Mon, 01 Feb 2021 11:20:23 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/layout/label-script.html</guid><description>参考链接：
图片讲解
1. 基础内容 1.1 加载执行 defer修饰的script的外部js的执行顺序在MDN上标明为按照位置执行，但在浏览器实现中没有按照此说法进行。
defer async 加载时刻 位置顺序 位置顺序 执行时刻 无法确定 先加载完先执行 2. 其它内容 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完全加载。
对于外部js操作dom，最好在DOMContentLoaded事件的回调中进行，市场中常见的框架都是如此，如angular等</description></item><item><title>浏览器输入url到网页展示期间发生了什么？</title><link>https://linjiasen63.github.io/posts/programming/base/network/things-about-from-url-to-html.html</link><pubDate>Tue, 29 Dec 2020 14:42:56 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/base/network/things-about-from-url-to-html.html</guid><description>1. 概要流程 DNS查找，确定ip 三次握手，建立链接 客户端发送请求 服务端返回响应 四次挥手，销毁链接 浏览器解析内容 2. 详细解释 2.1 DNS查找，确定IP 2.1.1 概述 逐一向“浏览器”、“操作系统”、“路由器”询问：是否知道ip地址？若知道则返回； 从本地系统向本地DNS服务器（电脑上网络配置中的dns，如8.8.8.8）发起迭代询问； 2.1.2 详情 查询IP（有两种方式，一般使用以下方式，减少根服务器的压力）
方式一：
1. “操作系统” -&amp;gt; “本地DNS服务器”查询 2. “本地DNS服务器” -&amp;gt; “根域名服务器”（ipv4，全球只有13个） 3. “本地DNS服务器” -&amp;gt; “顶级域名服务器” 1. 通用：如com、edu等 2. 地区：如cn、jp、等 3. 特殊：如 4. “本地DNS服务器” -&amp;gt; “权威域名服务器”（饲服务器） 方式二：（现实中几乎不会使用到）
1. “操作系统” -&amp;gt; “本地DNS服务器”查询 2. “本地DNS服务器” -&amp;gt; “根域名服务器” 3. “根域名服务器” -&amp;gt; “顶级域名服务器” 4. “顶级域名服务器” -&amp;gt; “权威域名服务器” 5. 然后把结果逐一返回 2.2 三次握手，建立链接 client发起建立连接，发送同步序列号：随机生成的x（本次发送信息开始的编号，以后逐次+1）； sever收到client内容，返回client下次的同步序列号为（x+1，因为已发送了一个包），然后生成server对应的同步序列号y； clent收到server内容，发送确认包（server下次的同步序列号为y+1）； sequenceDiagram Client -&amp;gt;&amp;gt; Server: SYN=1，seq=x（x是随机生成的） Server -&amp;gt;&amp;gt; Client: ACK=1, ack=x+1；SYN=1，seq=y（y是随机生成的） Client -&amp;gt;&amp;gt; Server: ACK=1，ack=y+1 为什么是三次握手而不是二次？原因：保证连接是尽量可靠的。
2.3 客户端发送请求 // 请求行 HTTP/1.1 baidu.com GET // 首部字段 Content-Type: text/html; charset=utf-8 // 请求体 2.</description></item><item><title>前端系列： 防抖与节流</title><link>https://linjiasen63.github.io/posts/programming/front/logic/debounce-throttle.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/logic/debounce-throttle.html</guid><description>避免重复操作
1. 防抖（debounce） 在任务频繁触发时，只有触发间隔大于指定间隔，任务才会执行。以最后一次操作开始计时
用途
search搜索联想关键词 window触发resize时 分为两种“非立即执行”与“立即执行”
非立即执行：触发事件后函数不会立即执行，而是在指定时间后执行，如果在指定时间内又触发了事件，则重新计算执行时间（即在最后一次触发事件的时刻起算过去指定时间后执行） 立即执行：触发事件后函数立即执行，而在指定时间后，触发事件才被再次执行，如果在之期间又触发了事件，则重新计算执行时间（即在最后一次触发事件的时刻起算过去指定时间后才能执行） // 执行clearTimeout(timer)后，timer仍存在(其部分内部属性被修改)，不会被赋值为null const debounce = function(fn, delay, immediate) { delay = parseInt(delay, 10) || 1000; let timer = null; return function() { if (timer) { clearTimeout(timer); } if (immediate) { // 立即执行 const callNow = !timer; timer = setTime(() =&amp;gt; { timer = null; }, delay); if (callNow) { fn.call(this, ...arguments); } } else { // 非立即执行 timer = setTimeout(() =&amp;gt; { fn.call(this, ...arguments); }, delay); } }; }; const print = function() { console.log(&amp;#39;print&amp;#39;); }; const debouncePrint = debounce(print, 1000); debouncePrint(); debouncePrint(); setTimeout(() =&amp;gt; { debouncePrint(); }, 500); 2.</description></item><item><title>前端系列：a标签知识</title><link>https://linjiasen63.github.io/posts/programming/front/model/label-a.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/model/label-a.html</guid><description>1. 样式注意点 其它问法：
如何解决a标点击后hover样式失效 正确顺序：link -&amp;gt; visited -&amp;gt; hover -&amp;gt; active
记忆方法：LoVe（love：喜欢） - HAte（hate：厌恶）
link 未访问时（一般省略为a） visited 鼠标点击后 hover 鼠标悬浮时 active 鼠标点击时</description></item><item><title>前端系列：css 选择器的优先级</title><link>https://linjiasen63.github.io/posts/programming/front/model/selector-priority.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/model/selector-priority.html</guid><description>优先级别从高到低如下所示：
无限大：!important 1000：内联选择器 0100：ID选择器 0010：类选择器、伪类选择器、属性选择器 0001：标签选择器、伪元素选择器 0000：通配符、子选择选择器、兄弟选择选择器 没有权限：如属性继承 经验证：（编写多层嵌套的div在chrome浏览器上进行验证） 1000 &amp;gt; 0xxx（即任何以0开头的权限），即1,0,0,0 &amp;gt; 0,255,0,0。</description></item><item><title>前端系列：dom基础</title><link>https://linjiasen63.github.io/posts/programming/front/layout/dom-basic.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/layout/dom-basic.html</guid><description>append与appendChild的区别 参考链接：MDN
ParentNode.append 方法在 ParentNode的最后一个子节点之后插入一组 Node 对象或 DOMString 对象。被插入的 DOMString 对象等价为 Text 节点。
差异 ParentNode.append()允许追加 DOMString 对象（即String），而 Node.appendChild() 只接受 Node 对象。 ParentNode.append() 没有返回值，而 Node.appendChild() 返回追加的 Node 对象。 ParentNode.append() 可以追加多个节点和字符串，而 Node.appendChild() 只能追加一个节点。 共同 如果添加的节点，是页面上存在的，会将其从原有的位置删除，然后放到新位置上。</description></item><item><title>前端系列：es5创建对象</title><link>https://linjiasen63.github.io/posts/programming/front/logic/object-create.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/logic/object-create.html</guid><description>es5及之前创建对象的常见模式。参考书籍：《javascript高级程序设计》（第3版）
1. 工厂模式 优点：解决创建多个相似对象的问题 缺点：没有解决对象识别的问题（即怎样知道对象的类型） function createObj(name) { var o = new Object(); o.name = name; o.sayName = function () { console.log(this.name); }; return o; } // 用法 var obj = createObj(&amp;#39;obj&amp;#39;); 2. 构造函数模式 优点：解决对象识别的问题（即怎样知道对象的类型） 缺点：各个方法都需要在各个实例上重新创建一遍 function Obj(name) { this.name = name; this.sayName = function() { console.log(this.name); }; } // 用法 var obj = new Obj(&amp;#39;obj&amp;#39;); 3. 原型模式 优点：解决对象识别的问题（即怎样知道对象的类型） 缺点：各个实例都共用所有属性与方法 function Obj (name) {} Obj.prototype.name = name; Obj.prototype.sayName = function () { console.log(this.name); }; } // 用法 var obj = new Obj(&amp;#39;obj&amp;#39;); 4. 组合模式 优点：解决对象识别的问题（即怎样知道对象的类型） 缺点：对象的属性定义与方法定义不在一起 function Obj(name) {} this.name = name; } Obj.</description></item><item><title>前端系列：es5继承</title><link>https://linjiasen63.github.io/posts/programming/front/logic/object-extend.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/logic/object-extend.html</guid><description>es5及之前实现继承的常见模式。参考书籍：《javascript高级程序设计》（第3版）
1. 原型链 优点： 缺点：无法向父类传递参数 function SuperType() { this.property = true; } SuperType.prototype.getSuperValue = function() { return this.property; }; function SubType() { this.subproperty = false; } // 继续了SuperType SubType.prototype = new SuperType(); SubType.prototype.getSubValue = function() { return this.subproperty; }; var instance = new SubType(); alert(instance.getSuperValue()); // true 2. 借用构造函数 优点： 缺点： function SuperType() { this.colors = [&amp;#39;red&amp;#39;, &amp;#39;blue&amp;#39;, &amp;#39;greee&amp;#39;]; } function SubType() { // 继承了SupperType SuperType.call(this); } var instance1 = new SubType(); instance1.colors.push(&amp;#39;black&amp;#39;); alert(instance1.colors); // &amp;#39;red,blud,green,black&amp;#39; var instance2 = new SubType(); alert(instance2.colors); // &amp;#39;red,blud,green&amp;#39; 3. 组合式继承 优点： 缺点： function SuperType(name) { this.name = name; this.</description></item><item><title>前端系列：input标签</title><link>https://linjiasen63.github.io/posts/programming/front/layout/label-input.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/layout/label-input.html</guid><description>1. 点击时依次触发的事件 1.1 验证方法 &amp;lt;html&amp;gt; &amp;lt;!-- ... --&amp;gt; &amp;lt;input id=&amp;#34;input&amp;#34;/&amp;gt; &amp;lt;script&amp;gt; const inputEle = document.getElementById(&amp;#39;input&amp;#39;); inputEle.onmouseenter = () =&amp;gt; { console.log(&amp;#39;---- onmouseenter&amp;#39;); } inputEle.onmousedown = () =&amp;gt; { console.log(&amp;#39;---- onmousedown&amp;#39;); } inputEle.onfocus = () =&amp;gt; { console.log(&amp;#39;---- onfocus&amp;#39;); } inputEle.onclick = () =&amp;gt; { console.log(&amp;#39;---- onclick&amp;#39;); } &amp;lt;/script&amp;gt; &amp;lt;!-- ... --&amp;gt; &amp;lt;/html&amp;gt; 1.2 最终结论 // 触发顺序如下 // mouseenter // mousedown // focus // click</description></item><item><title>前端系列：js代码性能测量</title><link>https://linjiasen63.github.io/posts/programming/front/other/performance-mark.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/other/performance-mark.html</guid><description>1. performance 利用 当前环境下的performance对象下的相应方法进行测量（某些浏览器存在兼容性问题）
// 标记当前时间 mark(markName) // 测量两次标记之间的间隔 measure(measureName, markNameOfStart, markNameOfEnd) // 清除指定标记（若没有指定则清除所有） clearMarks(?markName) // 清除指定测量（若没有指定则清除所有） clearMeasures(?measureName)</description></item><item><title>前端系列：promise简单实现</title><link>https://linjiasen63.github.io/posts/programming/front/logic/promise-simple.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/logic/promise-simple.html</guid><description>1. 简单Promise实现 // 1. 简单实现： class PromiseCustom { constructor(fn) { this.resolvedCallbacks = []; this.rejectedCallbacks = []; this.state = &amp;#39;PENDING&amp;#39;; this.value = &amp;#39;&amp;#39;; fn(this.resolve.bind(this), this.reject.bind(this)); } resolve(value) { if (this.state === &amp;#39;PENDING&amp;#39;) { this.state = &amp;#39;RESOLVED&amp;#39;; this.value = value; this.resolvedCallbacks.forEach((cb) =&amp;gt; cb(this.value)); } return this; } reject(value) { if (this.state === &amp;#39;REJECTED&amp;#39;) { this.state = &amp;#39;REJECTED&amp;#39;; this.value = value; this.rejectedCallbacks.forEach((cb) =&amp;gt; cb(this.value)); } } then(resolve = function () { }, reject = function () { }) { if (this.state === &amp;#39;PADDING&amp;#39;) { this.resolvedCallbacks.push(resolve); this.rejectedCallbacks.push(reject); } else if (this.state === &amp;#39;RESOLVED&amp;#39;) { resolve(this.value); } else if (this.state === &amp;#39;REJECTED&amp;#39;) { reject(this.value); } } } // 2.</description></item><item><title>前端系列：scrollbar样式</title><link>https://linjiasen63.github.io/posts/programming/front/model/scrollbar.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/model/scrollbar.html</guid><description>1. 配置滚动条的样式 /* 垂直滚动条 */ .wrapper::-webkit-scrollbar { width: 5px; height: 13px; -webkit-border-radius: 5px; -moz-border-radius: 5px; border-radius: 5px; -webkit-appearance: none; } .wrapper::-webkit-scrollbar-thumb { min-height: 28px; -webkit-border-radius: 5px; -moz-border-radius: 5px; border-radius: 5px; background-clip: padding-box; background-color: rgba(0, 0, 0, 0.3); } .wrapper::-webkit-scrollbar-thumb:hover { -webkit-border-radius: 5px; -moz-border-radius: 5px; border-radius: 5px; background-color: rgba(190, 89, 89, 0.3); }</description></item><item><title>前端系列：transform</title><link>https://linjiasen63.github.io/posts/programming/front/model/transform.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/model/transform.html</guid><description>transform-style 规定如何在3D空间中呈现被嵌套的元素。（必须与 transform 属性一同使用）
flat：子元素将忽略其3D位置（默认） preserve-3d：子元素将保留其3D位置 CSS中的坐标系 翻牌效果DEMO</description></item><item><title>前端系列：业务知识</title><link>https://linjiasen63.github.io/posts/programming/front/other/business-point.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/other/business-point.html</guid><description>1. 如何与父 window 通信（只有同一域下才可以）？ 在iframe所在页面上通过window.top可访问到顶层window
2. 跨域通信 参考链接
MDN otherWindow.postMessage(message, targetOrigin, [transfer]);</description></item><item><title>前端系列：动画实现方式</title><link>https://linjiasen63.github.io/posts/programming/front/model/animation-usage.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/model/animation-usage.html</guid><description>1. transition property duration timing-function delay 2. animation name duration timing-function delay iteration-count direction fill-mode 3. 时间函数 3.1 贝塞尔曲线 有过渡效果
ease ease-in ease-out ease-in-out 自定义属性 3.2 状态忽变 没有过渡效果，使用step()函数
4. js逻辑 4.1 动画事件监听 animationStart animationEnd 或者 transitionEnd animationIteration 事件名称需要考虑兼容性问题，如chrome浏览器下需要使用webkitAnimationStart代替等。
4.2 定时器 setTimeout或setInterval
不推荐使用
4.3 requestAnimationFrame 在移动端没有兼容性问题，但PC上需要考虑兼容性。
用法类似于setTimeout(callback, 1000)，只是不需要指定时间时间（由浏览器控制，在页面每次重绘前会执行回调函数，回调函数接收一个时间值），并返回一个标识，可用于取消当前操作（使用cancelRequestFrame）</description></item><item><title>前端系列：单页面应用实现原理</title><link>https://linjiasen63.github.io/posts/programming/front/other/spa-basic.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/other/spa-basic.html</guid><description>1. 2014年之前 浏览器在url的#之后内容变化时不会刷新页面，并监听“hashChange”事件，由前端处理路由变化
页面切换 location.href = nextUrl 等价于 location.assign(nextUrl) 页面替换 location.replace(nextUrl) 页面刷新 location.relod(); 2. 2014年之后 h5标准发布：新增方法（pushState、replaceState）修改url而不会刷新页面，并监听“popState”事件；同时需要服务作支持，所有路由重定向到根路由
页面切换 history.pushState(); 页面替换 history.replaceState(); 用法： history.pushState(stateObj, pageTitle, nextUrl);
stateObj — 状态对象state是一个JavaScript对象，通过pushState () 创建新的历史记录条目。无论什么时候用户导航到新的状态，popstate事件就会被触发，且该事件的state属性包含该历史记录条目状态对象的副本。状态对象可以是能被序列化的任何东西。原因在于Firefox将状态对象保存在用户的磁盘上，以便在用户重启浏览器时使用，我们规定了状态对象在序列化表示后有640k的大小限制。如果你给 pushState() 方法传了一个序列化后大于640k的状态对象，该方法会抛出异常。如果你需要更大的空间，建议使用 sessionStorage 以及 localStorage.
标题 — Firefox 目前忽略这个参数，但未来可能会用到。传递一个空字符串在这里是安全的，而在将来这是不安全的。二选一的话，你可以为跳转的state传递一个短标题。
nextUrl — 该参数定义了新的历史URL记录。注意，调用 pushState() 后浏览器并不会立即加载这个URL，但可能会在稍后某些情况下加载这个URL，比如在用户重新打开浏览器时。新URL不必须为绝对路径。如果新URL是相对路径，那么它将被作为相对于当前URL处理。新URL必须与当前URL同源，否则 pushState() 会抛出一个异常。该参数是可选的，缺省为当前URL。</description></item><item><title>前端系列：原型链关系</title><link>https://linjiasen63.github.io/posts/programming/front/logic/prototype-chain.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/logic/prototype-chain.html</guid><description>以下为相关规则:
js方法 有prototype属性与__proto__属性，如Object、Fuction；而 js对象 只有__proto__属性，如自定义对象：var o = {};
Object.prototype.__proto__ 为 null
Object.__proto__ 等于 Function.prototype
Function.prototype 等于 Function.__proto__
Function.prototype.__proto__ 等于 Object.prototype
var Person = function() {} // 即 new Function(); Person.__proto__ 等于 Function.prototype
var p = new Person(); p.__proto__ 等于 Person.prototype；Person.prototype.__proto__ 等于 Object.prototype
以下为命名约定:
任意对象的原型 简称为 {{对象名}}_Proto，如Object的原型 简称为 Object_Proto</description></item><item><title>前端系列：基础知识</title><link>https://linjiasen63.github.io/posts/programming/front/model/basic.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/model/basic.html</guid><description>1. 伪类与伪元素的区别 伪类：描述dom树上已存在元素的某个状态，并为其添加相应的样式，该状态可以根据用户的操作而改变。如:visited、:hover、:active等 伪元素：描述dom树上不存在元素，并为其添加相应的样式。如::before、::after等 伪类建议前缀为单冒号（:）；伪元素建议前缀为双冒号（::）。</description></item><item><title>前端系列：基础要点</title><link>https://linjiasen63.github.io/posts/programming/front/logic/basic-point.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/logic/basic-point.html</guid><description>1. 限制fn调用 限制某个函数只能通过“new”关键字调用（来源：vue源码）
function Vue() { if (!(this instanceof Vue)) { throw new Error(&amp;#39;vue is a constructor and should be called with the `new` keyword&amp;#39;) } } 2. instanceof 代码实现
function instanceofCustom(left, right) { if (!left || !right) return false; var obj = left; var proto = right &amp;amp;&amp;amp; right.prototype; for(;;) { if (!obj.__proto__) return false; if (obj.__proto__ === proto) return true; obj = obj.__proto__; } } 3. 浮点数计算注意事项 // const i = &amp;#39;int类型数据,如28&amp;#39;; // const j = i / 100 * 100; // 请问 i == j 是否恒成立，为什么？ // 结论： // 不恒成立，因为js中number类型的存储是以浮点类型的形式进行的。如28 4. try-catch 参考：
js中(try catch） 对代码的性能影响 结论</description></item><item><title>前端系列：布局知识（盒子模型）</title><link>https://linjiasen63.github.io/posts/programming/front/model/layout-point.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/model/layout-point.html</guid><description>1. 盒子模型 /* css盒子模型由box-sizing属性控制： box-sizing: content-box | border-box | inherit 其中：默认值是content-box 一、content-box 标准盒子模板 元素的真实宽度 = 内容宽度（content） + padding + border 即：width属性指定的大小 + 内边距 + 边框 二、border-box 低版本IE盒子模型 元素的真实宽度 = 内容宽度（content + padding + border） 即：width属性指定的大小（其中内边距与边框都会处在width之中） */ /* background属性是以content + padding + border来显示内容的。 跟box-sizing的属性值没有任何关系。 */ 2. 格式化上下文（BFC） 页面中盒模型布局的CSS渲染模式
2.1 形成条件 * display为以下其中之一的值 inline-block、table-cell、table-caption * 浮动元素：float除 none 以外的值 * 定位元素：position（absolute、fixed） * overflow 除了 visible 以外的值（hidden、auto、scroll） 2.2 基本特性 * 内部的box会在垂直方向上一个接一个的放置。 * 垂直方向上的距离由margin决定 * BFC的区域不会与 float 的元素区域重叠 * 计算BFC的高度时，浮动元素也参与计算 * BFC就是页面上一个独立容器，容器里面的子元素不会影响外面元素 使用flex布局时margin的上下margin塌陷不起作用
3 如何清除浮动 父元素不指定高度，子元素指定浮动后，父元素会发生高度塌陷。
3.1 示例代码 &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div class=&amp;#34;box1&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;subbox1&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;box2&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;style&amp;gt; .subbox1 { float: left; width: 10px; height: 10px; background-color: red; } .</description></item><item><title>前端系列：手写常见方法</title><link>https://linjiasen63.github.io/posts/programming/front/logic/coding-funciton.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/logic/coding-funciton.html</guid><description>1. new 原生实现：new Fn(...args)；自定义实现：newSelf(Fn, ...args)；
实现步骤：
校验传入的参数（Fn，args）（通过Array.prototype.slice获取） 创建空对象obj 将obj.__proto__赋值为Fn.prototype，obj.constructor赋值为Fn 将obj作为上下文，执行Fn 如果Fn有返回值result，则返回result；否则返回对象obj function newSelf() { var fn = Array.prototype.shift.call(arguments); if (typeof fn != &amp;#39;function&amp;#39;) { throw new Error(&amp;#34;The first param of the newSelf must be a function!&amp;#34;); } var obj = {}; obj.__proto__ = fn.prototype; obj.constructor = fn; var result = fn.apply(obj, arguments); return typeof result === &amp;#39;object&amp;#39; ? result : obj; } function Person(name) { this.name = name; } // test case var p = newSelf(Person, &amp;#39;小红&amp;#39;); console.log(&amp;#39;person str: &amp;#39;, p); console.log(&amp;#39;instanceof: &amp;#39;, p instanceof Person); 2. instanceof 原生实现：left instanceof right；自定义实现：instanceOfSelf(left, right)
实现步骤：
校验参数：left以及right 的合法性 获取obj=left.__proto; proto=right.prototype; 若obj为null，则返回false; 若obj===proto为ture，则返回true; 否则obj赋值为obj.</description></item><item><title>前端系列：执行上下文</title><link>https://linjiasen63.github.io/posts/programming/front/logic/eval-context.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/logic/eval-context.html</guid><description>1. arguments 严格模式下，不建议使用
1.1 arguments.callee 是一个指向正在执行的函数的指针，因此可以用它来实现对函数的递归调用。
// 原版函数 function factorial(num){ if (num &amp;lt;= 1){ return 1; } else { return num * factorial(num-1); } } function factorial(num){ if (num &amp;lt;= 1){ return 1; } else { return num * arguments.callee(num-1); } } 但在严格模式下，不能通过脚本访问 arguments.callee，访问这个属性会导致错误。不过，可 以使用命名函数表达式来达成相同的结果。例如：
var factorial = (function f(num){ if (num &amp;lt;= 1){ return 1; } else { return num * f(num-1); } }); 1.2 ${FunctionName}.caller （或arguments.callee.caller）返回一个对函数的引用，该函数调用了当前函数。
function callerDemo() { if (callerDemo.caller) { var a = callerDemo.caller.toString(); console.log(a); } else { console.log(&amp;#34;this is a top function&amp;#34;); } } function handleCaller() { callerDemo(); } // 顶层调用 callerDemo(); // 嵌套调用 handleCaller(); 2.</description></item><item><title>前端系列：样式相关</title><link>https://linjiasen63.github.io/posts/programming/front/model/flex-point.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/model/flex-point.html</guid><description>1. 以下代码中left与right的宽度分别是？ &amp;lt;div class=&amp;#34;container&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;left&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;right&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;style&amp;gt; .container { display: flex; width: 600px; height: 40px; } .left { flex-grow: 1; flex-shrink: 2; flex-basis: 500px; background: #2bff00; } .right { flex-grow: 2; flex-shrink: 1; flex-basis: 400px; background: #4396e2; } &amp;lt;/style&amp;gt; 计算规则：
若超过容器的宽度
子元素的位权：${shrink的比重} * ${原始宽度：如width或basis指定的} 子元素位权比：子元素位权 / 所有子元素位权之和 子元素的宽度：原始宽度 - 子元素位权比 * 超过的容器的宽度 即： 超出容器宽度：500 + 400 - 600 = 300 left的位重为：2 * 500 = 1000 left + right的位重和为： 2 * 500 + 1 * 400 = 1400 left的宽度：500 - 1000/1400*300 = 285.72 若容器有多余宽度
容器多余宽度：容器的宽度 - 子元素原始宽度之和 子元素位重比：子元素位重grow / 所有子元素位重grow之和 子元素的宽度：子元素原始宽度 + 子元素位重比 * 容器多余宽度 将上述题目中的css修改为：` flex-basis: initial;` 即： 超出容器宽度：600 - 0 = 600 left的位重比为：1 / (1 + 2) = 1/3 left的宽度：0 + 600*1/3 = 200 将上述题目中的css修改为：` flex-basis: 100px;` 即： 超出容器宽度：600 - 200 = 400 left的位重比为：1 / (1 + 2) = 1/3 left的宽度：200 + 400*1/3 = 233.</description></item><item><title>前端系列：请求知识</title><link>https://linjiasen63.github.io/posts/programming/front/other/request-basic.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/other/request-basic.html</guid><description>一. XMLHttpRequest 对象 1. 初始化值 1.1 适用于ie7之前 function createXHR() { if (typeof arguments.callee.activeXString != &amp;#39;string&amp;#39;) { var versions = [&amp;#39;MSXML3.XMLHttp.6.0&amp;#39;, &amp;#39;MSXML3.XMLHttp.3.0&amp;#39;, &amp;#39;MSXML2.XMLHttp&amp;#39;]; for (var i = 0; i &amp;lt; versions.length; i++) { try { var version = versions[i]; new ActiveXObject(version); arguments.callee.activeXString = version; break; } catch (err) { // 跳过 } } } return new ActiveXObject(arguments.callee.activeXString); } 1.2 适用于ie7之后 var xhr = new XMLHttpRequest(); 1.3 适用于所有版本 function createXHR() { if (typeof XMLHttpRequest != &amp;#39;undefined&amp;#39;) { return new XMLHttpRequest(); } else if (typeof ActiveXObject != &amp;#39;undefined&amp;#39;) { if (typeof arguments.callee.activeXString != &amp;#39;string&amp;#39;) { var versions = [&amp;#39;MSXML3.XMLHttp.6.0&amp;#39;, &amp;#39;MSXML3.XMLHttp.3.0&amp;#39;, &amp;#39;MSXML2.XMLHttp&amp;#39;]; for (var i = 0; i &amp;lt; versions.</description></item></channel></rss>
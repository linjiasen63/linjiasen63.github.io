<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>林三木的博客</title><link>https://linjiasen63.github.io/</link><description>Recent content on 林三木的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 01 Feb 2021 11:20:23 +0000</lastBuildDate><atom:link href="https://linjiasen63.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>前端系列：script标签的defer、async属性</title><link>https://linjiasen63.github.io/posts/programming/front/layout/label-script.html</link><pubDate>Mon, 01 Feb 2021 11:20:23 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/layout/label-script.html</guid><description>参考链接：
图片讲解
1. 基础内容 1.1 加载执行 defer修饰的script的外部js的执行顺序在MDN上标明为按照位置执行，但在浏览器实现中没有按照此说法进行。
defer async 加载时刻 位置顺序 位置顺序 执行时刻 无法确定 先加载完先执行 2. 其它内容 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完全加载。
对于外部js操作dom，最好在DOMContentLoaded事件的回调中进行，市场中常见的框架都是如此，如angular等</description></item><item><title>优秀简历的书写规范</title><link>https://linjiasen63.github.io/posts/life/common/resume.html</link><pubDate>Wed, 20 Jan 2021 17:37:28 +0000</pubDate><guid>https://linjiasen63.github.io/posts/life/common/resume.html</guid><description>1. 准则 1.1 四忌讳 把小成就当成大成就来说 把别人的成就说成是自己 平平淡淡，而无亮点 PPT，混淆简历与作品集 1.2 五要点 介绍自己：技能、成就与未来 资历与能力 注重能力而非光环 线性提升（选择隐藏某些经历） 表达简洁（简历不要超过两页）</description></item><item><title>人际关系</title><link>https://linjiasen63.github.io/posts/life/interpersonal-relationship/rules.html</link><pubDate>Mon, 11 Jan 2021 14:09:12 +0000</pubDate><guid>https://linjiasen63.github.io/posts/life/interpersonal-relationship/rules.html</guid><description>1. 自我 1.1 改变自己做事的态度 许多人都认为外事事物，是一个人快乐与否的重要因素之一，实际上恰恰相反，一个人对外界事物的反馈（是积极，还是消极）才是影响我们快乐与否的重要因素之一。
1.2 批评别人之前先想想 批评别人时，先想一下：如果处于相同的条件下，自己的表现又是怎样的，可能我们还不如呢。想当初我们刚开始工作时，是不是同样犯了很多低级错误。
人类拥有自尊心强，如果你直接对某个人说，某某你这里做错。大多数人即使在口头上承认，但在他们的内心不以为然，会找各种各样自我原谅的理由。在之后有很大的概率，同样的错误仍然会再次发生。
应该先委婉地说一下自己同样犯了类似的错误，引起共鸣，进而让别人更好接受自己犯错这件事，从而让其总结教训。
实际工作上，较难遇到这样的同事，但我们可以从自己做起，从而改变环境，而不是期望环境改变我们。</description></item><item><title>java进阶系列：jdbc</title><link>https://linjiasen63.github.io/posts/programming/java/java-ee/jdbc-basic.html</link><pubDate>Tue, 05 Jan 2021 08:48:40 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/java/java-ee/jdbc-basic.html</guid><description>jdbc：即java数据库连接，java database connectivity。本质上是java官方定义的一种规则（接口）：规定了如何操作数据库，具体的实现（又称为数据库驱动）由数据库厂商提供。
1. 基础知识 1.1 步骤 导入jar包 到官网下载对应的jar包 拷贝到项目中，右键，点击“add as library”即可 注册驱动 获取数据库连接对象 Connection 定义sql 获取执行sql语句的statement对象 执行sql，接受返回结果 处理结果 释放资源 1.2 示例 public class Main { public static void main(String[] args) { // 1. 导入jar包 // 2. 注册驱动 try { Class.forName(&amp;#34;com.mysql.cj.jdbc.Driver&amp;#34;); } catch (ClassNotFoundException e) { e.printStackTrace(); return } Connection conn = null; Statement stmt = null; try { // 3. 获取数据库连接对象 Connection conn = DriverManager.getConnection(&amp;#34;jdbc:mysql://127.0.0.1/test_db&amp;#34;, &amp;#34;root&amp;#34;, &amp;#34;********&amp;#34;); // 4. 定义sql String sql = &amp;#34;update stu set age = 10 where id = 1;&amp;#34;; // 5. 获取执行sql语句的statement对象 stmt = conn.createStatement(); // 6.</description></item><item><title>java基础系列：注解编程</title><link>https://linjiasen63.github.io/posts/programming/java/java-se/annotation.html</link><pubDate>Sun, 03 Jan 2021 20:35:46 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/java/java-se/annotation.html</guid><description>1. 基础 注解，又称元数据，jdk5之后引入的特性，与类、接口、枚举是同一层次。它可以声明在包、类、方法、局部变量、方法参数等的前面，用来对这些元素进行说明、注释
作用：
编写文档 代码分析 编译检查 2. 注解 @Override：检测方法是否继承父类（接口）的 @Deorecated：表示已过时 @SuppressWarnings：压制警告 一般传递参数all，即：@SuppressWarnings(&amp;ldquo;all&amp;rdquo;) 2.1 自定义注解 2.1.1 定义格式 本质上就是一个接口
元注解 public @interface 注解名称 { } public @interface MyAnnotation {} // 等价于下面的内容，即注解本质上就是一个接口（可通过反编译验证） public interface MyAnnotation extends java.lang.annotation.Annotation {} 2.1.2 约束条件 注解中属性的返回值只能是下列内容之一 基本数据类型 字符串 枚举 注解 以上类型数组 若定义了属性，则使用时必须给属性赋值 定义了属性，在使用时需要给属性赋值，除非定义时使用default关键字进行初始化。 如果只有一个属性需要赋值，且这个属性名称为value，那么可以省略为@MyAnnotation(&amp;quot;王大锤&amp;quot;) 数组赋值时使用{}包裹，如果只有一个值，则{}可省略 2.1.3 元注解 用于注解的注解
@Target：描述注解能作用的位置 TYPE：可以作用于类上 FIELD：可以作用于成员变量上 METHOD：可以作用于方法上 @Retention：描述注解能被保留的阶段 @Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，会被jvm使用 @Documented：描述注解是否能被抽取到api文档中 @Inherited：描述注解是否被子类继承 2.1.4 常用方法 // 获取Class对象的注解对象 public &amp;lt;A extends Annotation&amp;gt; A getAnnotation(Class&amp;lt;A&amp;gt; annotationClass) // 判断Class对象是否有指定的注解 public boolean isAnnotationPresent(Class&amp;lt;? extends Annotation&amp;gt; annotationClass) 2.</description></item><item><title>java基础系列：反射编程</title><link>https://linjiasen63.github.io/posts/programming/java/java-se/reflect.html</link><pubDate>Sun, 03 Jan 2021 20:00:45 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/java/java-se/reflect.html</guid><description>1. 基础 Student.java编译生成Student.class，然后通过类加载器将Student.class加载到内存中
public class Student { private int id; private String name; public Student() { } public Student(int id, String name) { this.id = id; this.name = name; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return &amp;#34;Student{&amp;#34; + &amp;#34;id=&amp;#34; + id + &amp;#34;, name=&amp;#39;&amp;#34; + name + &amp;#39;\&amp;#39;&amp;#39; + &amp;#39;}&amp;#39;; } } 1.1 获取Class对象 // 1 通过类的全路径字符串，可能抛出ClassNotFoundException // 多用于配置文件中 Class&amp;lt;Student&amp;gt; cls1 = (Class&amp;lt;Student&amp;gt;) Class.forName(&amp;#34;com.linjiasen.basic.Student&amp;#34;); // 2 通过类的class属性 // 多用于参数传递 Class&amp;lt;Student&amp;gt; cls2 = Student.</description></item><item><title>java基础系列：单元测试</title><link>https://linjiasen63.github.io/posts/programming/java/java-se/unit-test.html</link><pubDate>Sun, 03 Jan 2021 11:06:52 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/java/java-se/unit-test.html</guid><description>1. 通识知识 黑盒测试：不关注代码细节，只关注输入与输出是否符合预期。（一般不需要写代码） 白盒测试：关注代码的具体实现。 2. junit 建议：
测试用例 测试类名：&amp;ldquo;被测试的类名&amp;rdquo; + &amp;ldquo;Test&amp;rdquo;，如被测试的类为Calculator，那就叫做CalculatorTest 包名： xx.xx.xx.test，如：com.linjiasen.test 测试方法 方法名：&amp;ldquo;test&amp;rdquo; + &amp;ldquo;测试的方法名&amp;rdquo;，如测试方法为add，那就叫做testAdd 返回值：void 参数列表：空参 给方法加@Test 导入junit依赖 断言结果：红色失败，绿色成功。Assert.assertEquals() 2.1 代码实现 public class Calculator { /** * add * @param i * @param j * @return */ public int add(int i, int j) { return i + j; } /** * sub * @param i * @param j * @return */ public int sub(int i, int j) { return i - j - 1; } } public class CalculatorTest { private static Calculator c; @BeforeClass public static void beforeClass() { // 执行测试前的准备工作（如文件的初始化、数据库的连接操作等） System.</description></item><item><title>java基础系列：网络请求</title><link>https://linjiasen63.github.io/posts/programming/java/java-se/network-connect.html</link><pubDate>Fri, 01 Jan 2021 10:29:10 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/java/java-se/network-connect.html</guid><description>1. 通识 1.1 类型 C/S B/S 1.2 架构 应用层 传输层 网络层 链路层 数据链路层 物理层 1.3 协议 UDP：面向无链接。速度快，可能出现数据丢失，一般用于视频、音频。 TCP：面向链接。可靠，无差错的 1.4 三次握手 客户端发送链接请求 服务端回复请求 客户确认收到回复 1.5 其它 ipv4 ipv6 端口号由两个字节组成，在0~65535，期中0~1024之前的端口号已经被系统使用。
常用端口
80：默认 3306：mysql 1521：oracle 8080：tomcat 2. 基础内容 2.1 服务端 Server.java
public class Server { public static void main(String[] args) throws IOException { ServerSocket server = new ServerSocket(8888); Socket socket = server.accept(); InputStream is = socket.getInputStream(); byte[] bytes = new byte[1024]; int len = is.read(bytes); System.out.println(&amp;#34;服务端收到请求：&amp;#34; + new String(bytes, 0, len)); OutputStream os = socket.getOutputStream(); os.write(&amp;#34;你好&amp;#34;.getBytes()); socket.close(); } } 2.</description></item><item><title>我是谁？</title><link>https://linjiasen63.github.io/about.html</link><pubDate>Thu, 31 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/about.html</guid><description>谁都不能否认，我就是我思想的产物。我的思想又是什么呢？我思故我在，但在过去的28年，我从来没有想过这个问题，浑浑噩噩的活着，没有长远目标、计划。
初中升高中是这样的，高中升大学同样如此，大学毕业出来工作还是如此，工作5年了还是如此，从来没有为我的人生做过一个详细的规则。每天总是重复的事情，还远离社交（跟更少的人交流），节假日大多数都在租房上网冲浪，沉迷于自己的世界（小说、视频等奶头乐）。</description></item><item><title>java基础系列：输入输出</title><link>https://linjiasen63.github.io/posts/programming/java/java-se/intput-output.html</link><pubDate>Tue, 29 Dec 2020 23:34:31 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/java/java-se/intput-output.html</guid><description>1. File类 java.io.File，文件与目录的抽象表示形式
1.1 File的静态常量 // 与系统有关的路径分隔符 static String pathSeparator // 为方便，为字符串 static char pathSeparatorChar // mac: 冒号` :` // win: 分号` ;` // 与系统有关的默认名称分隔符 static String separator // 为方便，为字符串 static char separatorChar // mac: 正叙扛` /` // win: 反叙扛`\` 1.2 构造方法 public File(String pathname) public File(String parent, String child) public File(File parent, String child) 1.3 常用方法 1.3.1 获取 // 返回此File的绝对路径 public String getAbsolutePath() // 返回此File的创建时传入的path // toString就是调用getPath public String getPath() // 返回File表示文件或目录的名称 public String getName() // 返回File表示的文件长度，指向的文件大小， // 若为文件夹返回0；若文件不存在返回0 public long length() 1.3.2 判断 // 判断File表示的目录或文件是否存在 public boolean exists() // 判断是否为目录 public boolean isDirectory() // 判断是否为文件 public boolean isFile() 1.</description></item><item><title>java基础系列：函数编程</title><link>https://linjiasen63.github.io/posts/programming/java/java-se/functional.html</link><pubDate>Tue, 29 Dec 2020 23:16:42 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/java/java-se/functional.html</guid><description>1. Lambda表达式 从jdk8开始支持，条件如下：
必须具有接口，且接口中有仅仅有一个抽象方法 必须具有上下文推断 有且只有一个方法接口，称之为：函数式接口。
与匿名内部类的区别主要在于，编译后生成的文件。Lamada表达式不会生成class文件，而匿名内部类会。
public static void main(String[] args) { new Thread(() -&amp;gt; { System.out.println(&amp;#34;Hello world!&amp;#34;); }).start(); } 由以下组成：
一些参数 一个箭头 一段代码 标准格式：(参数列表) -&amp;gt; { 一些重写方法的代码 }
1.1 示例 public static void main(String[] args) { Integer[] arr = { 1, 2, 4, 3 }; Arrays.sort(arr, (Integer o1, Integer o2) -&amp;gt; { return o2 - o1; }); System.out.println(Arrays.toString(arr)); } 可推导，可省略。凡是根据上下文推导出来的内容都可以省略不写
括号中的参数列表的数据类型 括号中的参数列表只有一个，类型和()都可省略 如果{}中的代码只有一行，无论是否有返回值，都可以省略（{}，return, 分号），这三者需要一起省略。 public static void main(String[] args) { Integer[] arr = { 1, 2, 4, 3 }; Arrays.sort(arr, (o1, o2) -&amp;gt; o2 - o1); System.out.println(Arrays.toString(arr)); } 1.2 自定义函数式接口 // 使用注解可以进行校验 @FunctionalInterface public interface FuncInterface&amp;lt;T&amp;gt; { // 有且只有一个抽象方法，否则不是函数式接口 // 但可以有多个静态方法、默认方法、私有方法 public abstract T get(); } 2.</description></item><item><title>浏览器输入url到网页展示期间发生了什么？</title><link>https://linjiasen63.github.io/posts/programming/base/network/things-about-from-url-to-html.html</link><pubDate>Tue, 29 Dec 2020 14:42:56 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/base/network/things-about-from-url-to-html.html</guid><description>1. 概要流程 DNS查找，确定ip 三次握手，建立链接 客户端发送请求 服务端返回响应 四次挥手，销毁链接 浏览器解析内容 2. 详细解释 2.1 DNS查找，确定IP 2.1.1 概述 逐一向“浏览器”、“操作系统”、“路由器”询问：是否知道ip地址？若知道则返回； 从本地系统向本地DNS服务器（电脑上网络配置中的dns，如8.8.8.8）发起迭代询问； 2.1.2 详情 查询IP（有两种方式，一般使用以下方式，减少根服务器的压力）
方式一：
1. “操作系统” -&amp;gt; “本地DNS服务器”查询 2. “本地DNS服务器” -&amp;gt; “根域名服务器”（ipv4，全球只有13个） 3. “本地DNS服务器” -&amp;gt; “顶级域名服务器” 1. 通用：如com、edu等 2. 地区：如cn、jp、等 3. 特殊：如 4. “本地DNS服务器” -&amp;gt; “权威域名服务器”（饲服务器） 方式二：（现实中几乎不会使用到）
1. “操作系统” -&amp;gt; “本地DNS服务器”查询 2. “本地DNS服务器” -&amp;gt; “根域名服务器” 3. “根域名服务器” -&amp;gt; “顶级域名服务器” 4. “顶级域名服务器” -&amp;gt; “权威域名服务器” 5. 然后把结果逐一返回 2.2 三次握手，建立链接 client发起建立连接，发送同步序列号：随机生成的x（本次发送信息开始的编号，以后逐次+1）； sever收到client内容，返回client下次的同步序列号为（x+1，因为已发送了一个包），然后生成server对应的同步序列号y； clent收到server内容，发送确认包（server下次的同步序列号为y+1）； sequenceDiagram Client -&amp;gt;&amp;gt; Server: SYN=1，seq=x（x是随机生成的） Server -&amp;gt;&amp;gt; Client: ACK=1, ack=x+1；SYN=1，seq=y（y是随机生成的） Client -&amp;gt;&amp;gt; Server: ACK=1，ack=y+1 为什么是三次握手而不是二次？原因：保证连接是尽量可靠的。
2.3 客户端发送请求 // 请求行 HTTP/1.1 baidu.com GET // 首部字段 Content-Type: text/html; charset=utf-8 // 请求体 2.</description></item><item><title>快速入门vim的基本操作</title><link>https://linjiasen63.github.io/posts/programming/base/linux/vim-basic-usage.html</link><pubDate>Fri, 25 Dec 2020 16:43:35 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/base/linux/vim-basic-usage.html</guid><description>1. 工作模式 # 1. 进入 # vim 文件名 # 2. 退出 # 按下esc，然后输入 :wq # 3. 插入模式 # 输入i、a、o # 4. 编辑模板 # 命令以回车结束运行 # 显示行号：:set number 或 :set nu # 取消行号：:set nonumber 或 :set nonu # 删除： x # 复制： yy + p # 剪切： dd + p 1.1 插入命令 命令 作用 a 在光标所在字符后插入 A 在光标所在行尾插入 i 在光标所在字符前插入 I 在光标所在行首插入 o 在光标下插入新行 O 在光标上插入新行 1.2 跳转命令 命令 作用 :0 跳转到第一行 :$ 跳转到最后一行 :${行号} 跳转到指定行（如:56） gg 跳转到第一行 G 跳转到最后一行 ${行号}G 跳转到指定行（如$56） 0 移至行首（在某一行中） $ 移至行尾（在某一行中） 1.</description></item><item><title>方便bash脚本开发的要点</title><link>https://linjiasen63.github.io/posts/programming/base/linux/bash-program-point.html</link><pubDate>Fri, 25 Dec 2020 16:43:35 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/base/linux/bash-program-point.html</guid><description>一、set命令 参考链接
# 执行脚本的时候，如果遇到不存在的变量，Bash 默认忽略它 #使用以下命令可改变默认行为：即遇到不存在的变量就会报错，并停止执行 set -u # 全写 set -o nounset # 默认情况下，脚本执行后，屏幕只显示运行结果，没有其他内容。如果多个命令连续执行，它们的运行结果就会连续输出。有时会分不清，某一段内容是什么命令产生的。 set -x # 全写 set -o xtrace # 如果脚本里面有运行失败的命令（返回值非0），Bash 默认会继续执行后面的命令。 # 使用以下命令可改变默认行为，即脚本只要发生错误，就终止执行。 set -e # 注意：不适用于管道命令，可使用以下命令处理。 # 全写 set -o errexit # 只要一个子命令失败，整个管道命令就失败，脚本就会终止执行 set -o pipefail # 管理中子命令失败，就退出 set -eo pipefail 总结 # 写法一 set -euxo pipefail # 写法二 set -eux set -o pipefail</description></item><item><title>java基础系列：语法进阶</title><link>https://linjiasen63.github.io/posts/programming/java/java-se/syntax-advance.html</link><pubDate>Thu, 24 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/java/java-se/syntax-advance.html</guid><description>1. 常用接口 1.1 系统内置 1.1.1 Object // 子类可重写以定制输出内容 Object.toString(); // 子类可重写以定制对象比较 Object.equals(); 1.1.2 Objects // 对两个对象进行比较，防止空指针异常 Objects.equals(变量a, 变量b); 1.1.3 System public static long currentTimeMillis()：返回此毫秒为单位的当前时间 public static void arraycopy(object src, int srcPos, object dest, int destPos, int length)：将数组中的指定数据拷贝到另一个数组中 1.2 时间转换 1.2.1 Date java.util.Date表示时间和日期的类，特定的瞬间，精确到毫秒（千分之一秒）
时间戳是指从标准基准时间（历元），即1970年1月1日00:00:00(GMT：英国格林威治)以来的毫秒数
// 获取从历元到当前系统时间的毫秒数 long timestamp = System.currentTimeMillis(); // 注意：中国（CST）属于东八区，会把时间增加8个小时，即历元为：1970年1月1日08:00:00 // 获取当前时间（当前时区） Date d1 = new Date(); // 获取从历元经过指定毫秒的时间 Date d2 = new Date(0L); // 将日期转换为毫秒 long timestamp1 = d1.getTime(); // 转换本地时间（已过期） System.out.println(d1.toLocalString()); 1.2.2 DateFormat java.text.DateFormat，是抽象类。按照指定模式，进行日期与文本之间的转换。
SimpleDateFormat dateFormat = new SimpleDateFormat(&amp;#34;yyyy-MM-dd HH:mm:ss&amp;#34;); // 格式化 String dateStr = dateFormat.format(date); System.out.println(dateStr); // 2020-12-24 00:09:59 // 解析：可能throw exception date = dateFormat.</description></item><item><title>idea常用快捷键</title><link>https://linjiasen63.github.io/posts/programming/java/idea-keymap.html</link><pubDate>Fri, 18 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/java/idea-keymap.html</guid><description> mac快捷键 win快捷键 具休功能描述 option + / alt + / 代码提示（自定义配置） option + enter alt + enter 自动导包、或声明变量（光标需停留在相应的类名上） command + X ctrl + Y 删除光标所在行 command + D ctrl + D 复制光标所在行，插入到光标位置下方 command + option + L ctrl + alt + L 格式化代码 command + / ctrl + / 单行注释，再按取消注释 command + shift + / ctrl + shift + / 注释选中代码，再按取消注释 command + N alt + ins 自动生成代码，如get、set等方法 option + shift + ↑或↓ alt + shift + ↑或↓ 向上或向下移动光标所在行 shift + F6 shift + F6 重命名</description></item><item><title>java基础系列：语法基础</title><link>https://linjiasen63.github.io/posts/programming/java/java-se/syntax-basic.html</link><pubDate>Wed, 16 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/java/java-se/syntax-basic.html</guid><description>1. 计算机通识 1.1 进制转换 辗转相除法（十进制转换为其它进制） 位权累加法（其它进制转换为十进制） 1.2 存储单位 1bit = 位（表示0或1） 1Byte = 8bit （数据存储的最小单元） 1KB = 1024Byte 1MB = 1024KB 1GB = 1024MB 1TB = 1024GB 1PB = 1024TB &amp;hellip; 1.3 Java简介 95年发布，已有20来年的历史。目前大部分公司使用的主要版本还是java8。
java编写的程序是跨平台的，但是JVM是非跨平台的（每种平台都有各自版本的JVM）
JDK = 编译器等开发工具 + JRE； JRE = 运行类库 + JVM； 1.3.1 DOS 盘符切换，如：D: (${磁盘标识}:) 切换目录 cd 清除 cls （全写：clear screen） 退出 exit 1.3.2 安装 配置JAVA_HOME 配置PATH mac下无需如此，开发配置简单。
1.3.3 jshell 从java9开始支持
# 进入 jshell # 退出 /exit 2. 基本语法 2.1 HelloWorld // public的类名必须与文件名大小写一致 public class HelloWorld { // 程序的执行入口 public static void main(String[] args) { System.</description></item><item><title>60min入门mysql</title><link>https://linjiasen63.github.io/posts/programming/mysql/tutorial-basic.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/mysql/tutorial-basic.html</guid><description>1. 基础知识 1.1 连接 # 连接mysql简写 # mysql -u${帐号名称} -p[${帐号密码}] mysql -uroot -p # 连接mysql全写 # mysql --user=${帐号名称} --password[=${帐号密码}] mysql --user=root --password # 指定mysql的ip 或 port # mysql [-h${服务器ip地址}] [-P${服务器端口}] -u${帐号名称} -p[${帐号密码}] mysql -h49.233.143.65 -P3306 -uroot -p 1.2 注释 -- 单行注释 # 单行注释 /* 块注释 */ 1.3 分类 DDL：数据定义语言。如定义数据库以及表结构等 DML：数据操作语言。如添加、创建、删除数据库以及表的记录等 DQL：数据查询语言。如查询数据库以及表的记录等 DCL：数据控制语言。如授权GRANK等 数据库使用相关语言。如USE ${数据库名称}; 或 show DATABASES;等语句 1.4 备份 1.4.1 命令行 -- 一、备份 -- mysqldump -u${帐号} -p${密码} ${数据库名} &amp;gt; ${备份文件的位置} -- 二、恢复 -- 1. 登录数据库管理系统 -- 2. 创建指定名称数据库 -- 3. 使用数据库 -- 4. 恢复数据 -- source ${备份文件的位置} 1.5 其它 -- 输出所有系统变量 show variables; 2. DDL 2.1 库的操作 2.</description></item><item><title>git基础：cherry-pick</title><link>https://linjiasen63.github.io/posts/programming/base/git/cherry-pick.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/base/git/cherry-pick.html</guid><description>对于多分支的代码库，将代码从一个分支转移到另一个分支是常见需求。这时分两种情况。一种情况是，你需要另一个分支的所有代码变动，那么就采用合并（git merge）。另一种情况是，你只需要部分代码变动（某几个提交），这时可以采用 Cherry pick。
参考资料
阮一峰的 git cherry-pick 教程
1. 基本用法 git cherry-pick &amp;lt;commitHash&amp;gt; git cherry-pick &amp;lt;commitHashA&amp;gt; &amp;lt;commitHashB&amp;gt; # 转移从 A 到 B 的所有提交。(不包含A) # 它们必须按照正确的顺序放置：提交 A 必须早于提交 B，否则命令将失败，但不会报错 git cherry-pick &amp;lt;commitHashA&amp;gt;..&amp;lt;commitHashB&amp;gt; # 转移从 A 到 B 的所有提交。(包含A) git cherry-pick &amp;lt;commitHashA&amp;gt;^..&amp;lt;commitHashB&amp;gt; 2. 额外配置 # 打开外部编辑器，编辑提交信息 # -e，--edit # 只更新工作区和暂存区，不产生新的提交 # -n，--no-commit # 在提交信息的末尾追加一行(cherry picked from commit ...)，方便以后查到这个提交是如何产生的。 # -x # 在提交信息的末尾追加一行操作者的签名，表示是谁进行了这个操作 # -s，--signoff # 如果原始提交是一个合并节点，来自于两个分支的合并，那么 cherry pick 默认将失败，因为它不知道应该采用哪个分支的代码变动。 # -m配置项告诉 Git，应该采用哪个分支的变动。它的参数parent-number是一个从1开始的整数，代表原始提交的父分支编号。 # -m parent-number，--mainline parent-number 3. 代码冲突 如果操作过程中发生代码冲突，cherry pick 会停下来，让用户决定如何继续操作。
3.1 继续 用户解决代码冲突后，第一步将修改的文件重新加入暂存区（git add .），第二步使用下面的命令，让 cherry pick 过程继续执行。
git cherry-pick --continue 3.2 中止 发生代码冲突后，放弃合并，回到操作前的样子。
git cherry-pick --abort 3.3 退出 发生代码冲突后，退出 cherry pick，但是不回到操作前的样子。</description></item><item><title>git基础：合并部分内容</title><link>https://linjiasen63.github.io/posts/programming/base/git/merge.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/base/git/merge.html</guid><description>功能介绍：将devp分支的部分修改合并到prod分支
# 1. git checkout 想要合并的分支 git checkout prod # 2. 合并内容 # 合并目录 # git checkout 更改所属的分支 文件夹/** git checkout devp src/user/** # 合并文件 # git checkout 更改所属的分支 合并的文件 git checkout devp src/index.html</description></item><item><title>git基础：常见问题</title><link>https://linjiasen63.github.io/posts/programming/base/git/question.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/base/git/question.html</guid><description>配置ssh后还需要验证帐号与密码 原因：由于ssh只对以git@开头的仓库地址起作用（https仓库链接无效）。 有两种方法可解决此问题：
只需要将仓库地址以git@开头的； 在本地保存登录信息：执行命令 git config --global credential.helper store ，再执行git操作（ git pull 或 git push等 ），此时仍会要求输入帐号与密码（输入正确后以后操作就不再需要）； 控制台输出的内容中文字符被转码 首先试试用 git config --global core.quotepath false。 如果不行再进行以下操作。git --no-pager log 能不能显示中文，如果不可以，则设置pager为more： git config --global core.pager more
参考链接</description></item><item><title>git基础：撤销内容更改</title><link>https://linjiasen63.github.io/posts/programming/base/git/recover.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/base/git/recover.html</guid><description>git log # 得到你需要回退一次提交的commit id 1. 在工作区 # 撤销修改 # 1.2 撤销指定文件 git checkout 1.txt # 1.2 撤销全部文件 git checkout . 2. 已暂存（add） # 2.1 撤销某个文件 # git reset HEAD ${文件名} git reset HEAD 1.txt # 2.2 撤销全部文件 git reset HEAD . 3. 已commit # 3.1 回到其中你想要的某个版本（代码或文件会被删除） git reset --hard ${commit_id} # 3.2 回到上一次提交（代码或文件会被删除） git reset --hard HEAD^ # 3.3 回到上一次提交，但保留相应的修改内容到工作区中 git reset HEAD^ 4. 已经push # 4.1 回到指定的commit，之后commit都会被删除 # 删除本地仓库中的内容 # git reset --hard ${commit_id} git reset --hard 9ee7a57df2c510b578c96b9320a95d96ec7af282 # 强制提交一次，之前的错误提交会从远程仓库中删除 git push origin HEAD --force # 4.2 内容还原到指定的commit，之后的commit记录会被保留 # git revert ${commit_id} git revert 9ee7a57df2c510b578c96b9320a95d96ec7af282</description></item><item><title>前端系列： 防抖与节流</title><link>https://linjiasen63.github.io/posts/programming/front/logic/debounce-throttle.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/logic/debounce-throttle.html</guid><description>避免重复操作
1. 防抖（debounce） 在任务频繁触发时，只有触发间隔大于指定间隔，任务才会执行。以最后一次操作开始计时
用途
search搜索联想关键词 window触发resize时 分为两种“非立即执行”与“立即执行”
非立即执行：触发事件后函数不会立即执行，而是在指定时间后执行，如果在指定时间内又触发了事件，则重新计算执行时间（即在最后一次触发事件的时刻起算过去指定时间后执行） 立即执行：触发事件后函数立即执行，而在指定时间后，触发事件才被再次执行，如果在之期间又触发了事件，则重新计算执行时间（即在最后一次触发事件的时刻起算过去指定时间后才能执行） // 执行clearTimeout(timer)后，timer仍存在(其部分内部属性被修改)，不会被赋值为null const debounce = function(fn, delay, immediate) { delay = parseInt(delay, 10) || 1000; let timer = null; return function() { if (timer) { clearTimeout(timer); } if (immediate) { // 立即执行 const callNow = !timer; timer = setTime(() =&amp;gt; { timer = null; }, delay); if (callNow) { fn.call(this, ...arguments); } } else { // 非立即执行 timer = setTimeout(() =&amp;gt; { fn.call(this, ...arguments); }, delay); } }; }; const print = function() { console.log(&amp;#39;print&amp;#39;); }; const debouncePrint = debounce(print, 1000); debouncePrint(); debouncePrint(); setTimeout(() =&amp;gt; { debouncePrint(); }, 500); 2.</description></item><item><title>前端系列：a标签知识</title><link>https://linjiasen63.github.io/posts/programming/front/model/label-a.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/model/label-a.html</guid><description>1. 样式注意点 其它问法：
如何解决a标点击后hover样式失效 正确顺序：link -&amp;gt; visited -&amp;gt; hover -&amp;gt; active
记忆方法：LoVe（love：喜欢） - HAte（hate：厌恶）
link 未访问时（一般省略为a） visited 鼠标点击后 hover 鼠标悬浮时 active 鼠标点击时</description></item><item><title>前端系列：css 选择器的优先级</title><link>https://linjiasen63.github.io/posts/programming/front/model/selector-priority.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/model/selector-priority.html</guid><description>优先级别从高到低如下所示：
无限大：!important 1000：内联选择器 0100：ID选择器 0010：类选择器、伪类选择器、属性选择器 0001：标签选择器、伪元素选择器 0000：通配符、子选择选择器、兄弟选择选择器 没有权限：如属性继承 经验证：（编写多层嵌套的div在chrome浏览器上进行验证） 1000 &amp;gt; 0xxx（即任何以0开头的权限），即1,0,0,0 &amp;gt; 0,255,0,0。</description></item><item><title>前端系列：dom基础</title><link>https://linjiasen63.github.io/posts/programming/front/layout/dom-basic.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/layout/dom-basic.html</guid><description>append与appendChild的区别 参考链接：MDN
ParentNode.append 方法在 ParentNode的最后一个子节点之后插入一组 Node 对象或 DOMString 对象。被插入的 DOMString 对象等价为 Text 节点。
差异 ParentNode.append()允许追加 DOMString 对象（即String），而 Node.appendChild() 只接受 Node 对象。 ParentNode.append() 没有返回值，而 Node.appendChild() 返回追加的 Node 对象。 ParentNode.append() 可以追加多个节点和字符串，而 Node.appendChild() 只能追加一个节点。 共同 如果添加的节点，是页面上存在的，会将其从原有的位置删除，然后放到新位置上。</description></item><item><title>前端系列：es5创建对象</title><link>https://linjiasen63.github.io/posts/programming/front/logic/object-create.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/logic/object-create.html</guid><description>es5及之前创建对象的常见模式。参考书籍：《javascript高级程序设计》（第3版）
1. 工厂模式 优点：解决创建多个相似对象的问题 缺点：没有解决对象识别的问题（即怎样知道对象的类型） function createObj(name) { var o = new Object(); o.name = name; o.sayName = function () { console.log(this.name); }; return o; } // 用法 var obj = createObj(&amp;#39;obj&amp;#39;); 2. 构造函数模式 优点：解决对象识别的问题（即怎样知道对象的类型） 缺点：各个方法都需要在各个实例上重新创建一遍 function Obj(name) { this.name = name; this.sayName = function() { console.log(this.name); }; } // 用法 var obj = new Obj(&amp;#39;obj&amp;#39;); 3. 原型模式 优点：解决对象识别的问题（即怎样知道对象的类型） 缺点：各个实例都共用所有属性与方法 function Obj (name) {} Obj.prototype.name = name; Obj.prototype.sayName = function () { console.log(this.name); }; } // 用法 var obj = new Obj(&amp;#39;obj&amp;#39;); 4. 组合模式 优点：解决对象识别的问题（即怎样知道对象的类型） 缺点：对象的属性定义与方法定义不在一起 function Obj(name) {} this.name = name; } Obj.</description></item><item><title>前端系列：es5继承</title><link>https://linjiasen63.github.io/posts/programming/front/logic/object-extend.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/logic/object-extend.html</guid><description>es5及之前实现继承的常见模式。参考书籍：《javascript高级程序设计》（第3版）
1. 原型链 优点： 缺点：无法向父类传递参数 function SuperType() { this.property = true; } SuperType.prototype.getSuperValue = function() { return this.property; }; function SubType() { this.subproperty = false; } // 继续了SuperType SubType.prototype = new SuperType(); SubType.prototype.getSubValue = function() { return this.subproperty; }; var instance = new SubType(); alert(instance.getSuperValue()); // true 2. 借用构造函数 优点： 缺点： function SuperType() { this.colors = [&amp;#39;red&amp;#39;, &amp;#39;blue&amp;#39;, &amp;#39;greee&amp;#39;]; } function SubType() { // 继承了SupperType SuperType.call(this); } var instance1 = new SubType(); instance1.colors.push(&amp;#39;black&amp;#39;); alert(instance1.colors); // &amp;#39;red,blud,green,black&amp;#39; var instance2 = new SubType(); alert(instance2.colors); // &amp;#39;red,blud,green&amp;#39; 3. 组合式继承 优点： 缺点： function SuperType(name) { this.name = name; this.</description></item><item><title>前端系列：gulp概要</title><link>https://linjiasen63.github.io/posts/programming/front/builder/gulp/basic-usage.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/builder/gulp/basic-usage.html</guid><description>参考资料
gulp英文官网 gulp中文网站 gulp插件查找 1. 基础入门 前置条件：默认已安装好node
安装命令行工具
npm install --global gulp-cli 初始化项目内容
npx mkdirp gulp-demo // 创建文件夹 cd gulp-demo npm init -y // 初始化 npm，默认使用缺省配置 npm install --save-dev gulp // 安装 gulp 在项目根目录下新建文件 gulpfile.js，文件内容如下
function defaultTask(cb) { // place code for your default task here console.log(&amp;#39;hello world&amp;#39;); cb(); } exports.default = defaultTask 在项目根目录下执行gulp命令，会输出以下gulp提示以及内容
hello world 任务类型
const { series, parallel } = require(&amp;#39;gulp&amp;#39;); // 公开任务（通过exports导出的，可以在命令行使用 gulp task01 调用） function task01(cb) { // body omitted cb(); } // 私有任务 function task02(cb) { // body omitted cb(); } exports.</description></item><item><title>前端系列：input标签</title><link>https://linjiasen63.github.io/posts/programming/front/layout/label-input.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/layout/label-input.html</guid><description>1. 点击时依次触发的事件 1.1 验证方法 &amp;lt;html&amp;gt; &amp;lt;!-- ... --&amp;gt; &amp;lt;input id=&amp;#34;input&amp;#34;/&amp;gt; &amp;lt;script&amp;gt; const inputEle = document.getElementById(&amp;#39;input&amp;#39;); inputEle.onmouseenter = () =&amp;gt; { console.log(&amp;#39;---- onmouseenter&amp;#39;); } inputEle.onmousedown = () =&amp;gt; { console.log(&amp;#39;---- onmousedown&amp;#39;); } inputEle.onfocus = () =&amp;gt; { console.log(&amp;#39;---- onfocus&amp;#39;); } inputEle.onclick = () =&amp;gt; { console.log(&amp;#39;---- onclick&amp;#39;); } &amp;lt;/script&amp;gt; &amp;lt;!-- ... --&amp;gt; &amp;lt;/html&amp;gt; 1.2 最终结论 // 触发顺序如下 // mouseenter // mousedown // focus // click</description></item><item><title>前端系列：js代码性能测量</title><link>https://linjiasen63.github.io/posts/programming/front/other/performance-mark.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/other/performance-mark.html</guid><description>1. performance 利用 当前环境下的performance对象下的相应方法进行测量（某些浏览器存在兼容性问题）
// 标记当前时间 mark(markName) // 测量两次标记之间的间隔 measure(measureName, markNameOfStart, markNameOfEnd) // 清除指定标记（若没有指定则清除所有） clearMarks(?markName) // 清除指定测量（若没有指定则清除所有） clearMeasures(?measureName)</description></item><item><title>前端系列：promise简单实现</title><link>https://linjiasen63.github.io/posts/programming/front/logic/promise-simple.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/logic/promise-simple.html</guid><description>1. 简单Promise实现 // 1. 简单实现： class PromiseCustom { constructor(fn) { this.resolvedCallbacks = []; this.rejectedCallbacks = []; this.state = &amp;#39;PENDING&amp;#39;; this.value = &amp;#39;&amp;#39;; fn(this.resolve.bind(this), this.reject.bind(this)); } resolve(value) { if (this.state === &amp;#39;PENDING&amp;#39;) { this.state = &amp;#39;RESOLVED&amp;#39;; this.value = value; this.resolvedCallbacks.forEach((cb) =&amp;gt; cb(this.value)); } return this; } reject(value) { if (this.state === &amp;#39;REJECTED&amp;#39;) { this.state = &amp;#39;REJECTED&amp;#39;; this.value = value; this.rejectedCallbacks.forEach((cb) =&amp;gt; cb(this.value)); } } then(resolve = function () { }, reject = function () { }) { if (this.state === &amp;#39;PADDING&amp;#39;) { this.resolvedCallbacks.push(resolve); this.rejectedCallbacks.push(reject); } else if (this.state === &amp;#39;RESOLVED&amp;#39;) { resolve(this.value); } else if (this.state === &amp;#39;REJECTED&amp;#39;) { reject(this.value); } } } // 2.</description></item><item><title>前端系列：scrollbar样式</title><link>https://linjiasen63.github.io/posts/programming/front/model/scrollbar.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/model/scrollbar.html</guid><description>1. 配置滚动条的样式 /* 垂直滚动条 */ .wrapper::-webkit-scrollbar { width: 5px; height: 13px; -webkit-border-radius: 5px; -moz-border-radius: 5px; border-radius: 5px; -webkit-appearance: none; } .wrapper::-webkit-scrollbar-thumb { min-height: 28px; -webkit-border-radius: 5px; -moz-border-radius: 5px; border-radius: 5px; background-clip: padding-box; background-color: rgba(0, 0, 0, 0.3); } .wrapper::-webkit-scrollbar-thumb:hover { -webkit-border-radius: 5px; -moz-border-radius: 5px; border-radius: 5px; background-color: rgba(190, 89, 89, 0.3); }</description></item><item><title>前端系列：transform</title><link>https://linjiasen63.github.io/posts/programming/front/model/transform.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/model/transform.html</guid><description>transform-style 规定如何在3D空间中呈现被嵌套的元素。（必须与 transform 属性一同使用）
flat：子元素将忽略其3D位置（默认） preserve-3d：子元素将保留其3D位置 CSS中的坐标系 翻牌效果DEMO</description></item><item><title>前端系列：webpack简单实现</title><link>https://linjiasen63.github.io/posts/programming/front/builder/webpack/webpack-simple.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/builder/webpack/webpack-simple.html</guid><description>1. 简单的实现 // 实现步骤 // 1. 创建模块内容：createAsset // 1. 读取模块内容fs.readFileSync，并利用parser得到抽象语法树ast // 2. 利用traverse遍历ast，在ImportDeclaration得到当前模块的所有依赖dependecies // 3. 利用@babel/core与perset-env将ast转换为浏览器可执行的代码 // 2. 递归创建依赖关系图：crateGraph // 1. 通过配置的入口创建主资源mainAsset（通过createAsset），并将其放到队列中queue // 2. 遍历queue，得到某个asset // 3. 遍历asset的dependencies，以创建子资源childAsset（通过createAsset），并在父asset记录mapping（保存相对路径与moduleId之间的映射关系），然后把子资源childAsset放入队列queue中 // 3. 生成可执行代码字符串：build // 1. 遍历graph,生成modules字符串，格式为：`{ 0: [ function(require, module, export) { ${资源的code(babel转译的结题)} } , ${ 依赖映射关系的josn字符串 } ] }` // 2. 返回IIFE // 4. 可通过fs.writeFileSync将内容保存到文件中 const path = require(&amp;#39;path&amp;#39;); const fs = require(&amp;#39;fs&amp;#39;); const parser = require(&amp;#39;@babel/parser&amp;#39;); const traverse = require(&amp;#39;@babel/traverse&amp;#39;).default; const babel = require(&amp;#39;@babel/core&amp;#39;); let moduleId = 0; // 1. 创建模块内容：createAsset function createAsset(filename) { const content = fs.readFileSync(filename, &amp;#39;utf-8&amp;#39;); const ast = parser.parse(content, { sourceType: &amp;#39;module&amp;#39;, }); const dependencies = []; traverse(ast, { ImportDeclaration({ node }){ dependencies.</description></item><item><title>前端系列：业务知识</title><link>https://linjiasen63.github.io/posts/programming/front/other/business-point.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/other/business-point.html</guid><description>1. 如何与父 window 通信（只有同一域下才可以）？ 在iframe所在页面上通过window.top可访问到顶层window
2. 跨域通信 参考链接
MDN otherWindow.postMessage(message, targetOrigin, [transfer]);</description></item><item><title>前端系列：动画实现方式</title><link>https://linjiasen63.github.io/posts/programming/front/model/animation-usage.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/model/animation-usage.html</guid><description>1. transition property duration timing-function delay 2. animation name duration timing-function delay iteration-count direction fill-mode 3. 时间函数 3.1 贝塞尔曲线 有过渡效果
ease ease-in ease-out ease-in-out 自定义属性 3.2 状态忽变 没有过渡效果，使用step()函数
4. js逻辑 4.1 动画事件监听 animationStart animationEnd 或者 transitionEnd animationIteration 事件名称需要考虑兼容性问题，如chrome浏览器下需要使用webkitAnimationStart代替等。
4.2 定时器 setTimeout或setInterval
不推荐使用
4.3 requestAnimationFrame 在移动端没有兼容性问题，但PC上需要考虑兼容性。
用法类似于setTimeout(callback, 1000)，只是不需要指定时间时间（由浏览器控制，在页面每次重绘前会执行回调函数，回调函数接收一个时间值），并返回一个标识，可用于取消当前操作（使用cancelRequestFrame）</description></item><item><title>前端系列：单页面应用实现原理</title><link>https://linjiasen63.github.io/posts/programming/front/other/spa-basic.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/other/spa-basic.html</guid><description>1. 2014年之前 浏览器在url的#之后内容变化时不会刷新页面，并监听“hashChange”事件，由前端处理路由变化
页面切换 location.href = nextUrl 等价于 location.assign(nextUrl) 页面替换 location.replace(nextUrl) 页面刷新 location.relod(); 2. 2014年之后 h5标准发布：新增方法（pushState、replaceState）修改url而不会刷新页面，并监听“popState”事件；同时需要服务作支持，所有路由重定向到根路由
页面切换 history.pushState(); 页面替换 history.replaceState(); 用法： history.pushState(stateObj, pageTitle, nextUrl);
stateObj — 状态对象state是一个JavaScript对象，通过pushState () 创建新的历史记录条目。无论什么时候用户导航到新的状态，popstate事件就会被触发，且该事件的state属性包含该历史记录条目状态对象的副本。状态对象可以是能被序列化的任何东西。原因在于Firefox将状态对象保存在用户的磁盘上，以便在用户重启浏览器时使用，我们规定了状态对象在序列化表示后有640k的大小限制。如果你给 pushState() 方法传了一个序列化后大于640k的状态对象，该方法会抛出异常。如果你需要更大的空间，建议使用 sessionStorage 以及 localStorage.
标题 — Firefox 目前忽略这个参数，但未来可能会用到。传递一个空字符串在这里是安全的，而在将来这是不安全的。二选一的话，你可以为跳转的state传递一个短标题。
nextUrl — 该参数定义了新的历史URL记录。注意，调用 pushState() 后浏览器并不会立即加载这个URL，但可能会在稍后某些情况下加载这个URL，比如在用户重新打开浏览器时。新URL不必须为绝对路径。如果新URL是相对路径，那么它将被作为相对于当前URL处理。新URL必须与当前URL同源，否则 pushState() 会抛出一个异常。该参数是可选的，缺省为当前URL。</description></item><item><title>前端系列：原型链关系</title><link>https://linjiasen63.github.io/posts/programming/front/logic/prototype-chain.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/logic/prototype-chain.html</guid><description>以下为相关规则:
js方法 有prototype属性与__proto__属性，如Object、Fuction；而 js对象 只有__proto__属性，如自定义对象：var o = {};
Object.prototype.__proto__ 为 null
Object.__proto__ 等于 Function.prototype
Function.prototype 等于 Function.__proto__
Function.prototype.__proto__ 等于 Object.prototype
var Person = function() {} // 即 new Function(); Person.__proto__ 等于 Function.prototype
var p = new Person(); p.__proto__ 等于 Person.prototype；Person.prototype.__proto__ 等于 Object.prototype
以下为命名约定:
任意对象的原型 简称为 {{对象名}}_Proto，如Object的原型 简称为 Object_Proto</description></item><item><title>前端系列：基础知识</title><link>https://linjiasen63.github.io/posts/programming/front/model/basic.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/model/basic.html</guid><description>1. 伪类与伪元素的区别 伪类：描述dom树上已存在元素的某个状态，并为其添加相应的样式，该状态可以根据用户的操作而改变。如:visited、:hover、:active等 伪元素：描述dom树上不存在元素，并为其添加相应的样式。如::before、::after等 伪类建议前缀为单冒号（:）；伪元素建议前缀为双冒号（::）。</description></item><item><title>前端系列：基础要点</title><link>https://linjiasen63.github.io/posts/programming/front/logic/basic-point.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/logic/basic-point.html</guid><description>1. 限制fn调用 限制某个函数只能通过“new”关键字调用（来源：vue源码）
function Vue() { if (!(this instanceof Vue)) { throw new Error(&amp;#39;vue is a constructor and should be called with the `new` keyword&amp;#39;) } } 2. instanceof 代码实现
function instanceofCustom(left, right) { if (!left || !right) return false; var obj = left; var proto = right &amp;amp;&amp;amp; right.prototype; for(;;) { if (!obj.__proto__) return false; if (obj.__proto__ === proto) return true; obj = obj.__proto__; } } 3. 浮点数计算注意事项 // const i = &amp;#39;int类型数据,如28&amp;#39;; // const j = i / 100 * 100; // 请问 i == j 是否恒成立，为什么？ // 结论： // 不恒成立，因为js中number类型的存储是以浮点类型的形式进行的。如28 4. try-catch 参考：
js中(try catch） 对代码的性能影响 结论</description></item><item><title>前端系列：布局知识（盒子模型）</title><link>https://linjiasen63.github.io/posts/programming/front/model/layout-point.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/model/layout-point.html</guid><description>1. 盒子模型 /* css盒子模型由box-sizing属性控制： box-sizing: content-box | border-box | inherit 其中：默认值是content-box 一、content-box 标准盒子模板 元素的真实宽度 = 内容宽度（content） + padding + border 即：width属性指定的大小 + 内边距 + 边框 二、border-box 低版本IE盒子模型 元素的真实宽度 = 内容宽度（content + padding + border） 即：width属性指定的大小（其中内边距与边框都会处在width之中） */ /* background属性是以content + padding + border来显示内容的。 跟box-sizing的属性值没有任何关系。 */ 2. 格式化上下文（BFC） 页面中盒模型布局的CSS渲染模式
2.1 形成条件 * display为以下其中之一的值 inline-block、table-cell、table-caption * 浮动元素：float除 none 以外的值 * 定位元素：position（absolute、fixed） * overflow 除了 visible 以外的值（hidden、auto、scroll） 2.2 基本特性 * 内部的box会在垂直方向上一个接一个的放置。 * 垂直方向上的距离由margin决定 * BFC的区域不会与 float 的元素区域重叠 * 计算BFC的高度时，浮动元素也参与计算 * BFC就是页面上一个独立容器，容器里面的子元素不会影响外面元素 使用flex布局时margin的上下margin塌陷不起作用
3 如何清除浮动 父元素不指定高度，子元素指定浮动后，父元素会发生高度塌陷。
3.1 示例代码 &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div class=&amp;#34;box1&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;subbox1&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;box2&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;style&amp;gt; .subbox1 { float: left; width: 10px; height: 10px; background-color: red; } .</description></item><item><title>前端系列：快速开始</title><link>https://linjiasen63.github.io/posts/programming/front/framework/react/basic-usage.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/framework/react/basic-usage.html</guid><description>1. 基础知识 1.1 环境搭建 node 包管理（npm、yarn） create-react-app 项目目录基本结构了解 1.2 你好世界 文件： public/index.html
&amp;lt;html&amp;gt; &amp;lt;header&amp;gt; &amp;lt;!-- 省略 --&amp;gt; &amp;lt;/header&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&amp;#34;root&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 文件： src/index.js
import React from &amp;#39;react&amp;#39;; // 用于当前页面识别jsx语法（不可省略） import ReactDOM from &amp;#39;react-dom&amp;#39;; import App from &amp;#39;./App&amp;#39; // 将相应的节点挂载到页面 ReactDOM.reander(&amp;lt;App /&amp;gt;, document.getElementById(&amp;#39;root&amp;#39;)); 文件： src/App.js
import React, { Component } from &amp;#39;react&amp;#39;; // 自定义组件的命名规则：首字母大写 class App extends Components { render() { return ( &amp;lt;div&amp;gt;你好世界！&amp;lt;/div&amp;gt; ) } } // 必须手动声明导出才能被外部使用 export default App; 1.3 基本内容 jsx限制： render返回的节点只能有一个根结点
{ /* 错误做法（编译不通过） */ } render() { return ( &amp;lt;div&amp;gt;你好世界1！&amp;lt;/div&amp;gt; &amp;lt;div&amp;gt;你好世界2！&amp;lt;/div&amp;gt; ) } { /* 正确做法 */ } { // 使用 React.</description></item><item><title>前端系列：手写常见方法</title><link>https://linjiasen63.github.io/posts/programming/front/logic/coding-funciton.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/logic/coding-funciton.html</guid><description>1. new 原生实现：new Fn(...args)；自定义实现：newSelf(Fn, ...args)；
实现步骤：
校验传入的参数（Fn，args）（通过Array.prototype.slice获取） 创建空对象obj 将obj.__proto__赋值为Fn.prototype，obj.constructor赋值为Fn 将obj作为上下文，执行Fn 如果Fn有返回值result，则返回result；否则返回对象obj function newSelf() { var fn = Array.prototype.shift.call(arguments); if (typeof fn != &amp;#39;function&amp;#39;) { throw new Error(&amp;#34;The first param of the newSelf must be a function!&amp;#34;); } var obj = {}; obj.__proto__ = fn.prototype; obj.constructor = fn; var result = fn.apply(obj, arguments); return typeof result === &amp;#39;object&amp;#39; ? result : obj; } function Person(name) { this.name = name; } // test case var p = newSelf(Person, &amp;#39;小红&amp;#39;); console.log(&amp;#39;person str: &amp;#39;, p); console.log(&amp;#39;instanceof: &amp;#39;, p instanceof Person); 2. instanceof 原生实现：left instanceof right；自定义实现：instanceOfSelf(left, right)
实现步骤：
校验参数：left以及right 的合法性 获取obj=left.__proto; proto=right.prototype; 若obj为null，则返回false; 若obj===proto为ture，则返回true; 否则obj赋值为obj.</description></item><item><title>前端系列：执行上下文</title><link>https://linjiasen63.github.io/posts/programming/front/logic/eval-context.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/logic/eval-context.html</guid><description>1. arguments 严格模式下，不建议使用
1.1 arguments.callee 是一个指向正在执行的函数的指针，因此可以用它来实现对函数的递归调用。
// 原版函数 function factorial(num){ if (num &amp;lt;= 1){ return 1; } else { return num * factorial(num-1); } } function factorial(num){ if (num &amp;lt;= 1){ return 1; } else { return num * arguments.callee(num-1); } } 但在严格模式下，不能通过脚本访问 arguments.callee，访问这个属性会导致错误。不过，可 以使用命名函数表达式来达成相同的结果。例如：
var factorial = (function f(num){ if (num &amp;lt;= 1){ return 1; } else { return num * f(num-1); } }); 1.2 ${FunctionName}.caller （或arguments.callee.caller）返回一个对函数的引用，该函数调用了当前函数。
function callerDemo() { if (callerDemo.caller) { var a = callerDemo.caller.toString(); console.log(a); } else { console.log(&amp;#34;this is a top function&amp;#34;); } } function handleCaller() { callerDemo(); } // 顶层调用 callerDemo(); // 嵌套调用 handleCaller(); 2.</description></item><item><title>前端系列：样式相关</title><link>https://linjiasen63.github.io/posts/programming/front/model/flex-point.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/model/flex-point.html</guid><description>1. 以下代码中left与right的宽度分别是？ &amp;lt;div class=&amp;#34;container&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;left&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;right&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;style&amp;gt; .container { display: flex; width: 600px; height: 40px; } .left { flex-grow: 1; flex-shrink: 2; flex-basis: 500px; background: #2bff00; } .right { flex-grow: 2; flex-shrink: 1; flex-basis: 400px; background: #4396e2; } &amp;lt;/style&amp;gt; 计算规则：
若超过容器的宽度
子元素的位权：${shrink的比重} * ${原始宽度：如width或basis指定的} 子元素位权比：子元素位权 / 所有子元素位权之和 子元素的宽度：原始宽度 - 子元素位权比 * 超过的容器的宽度 即： 超出容器宽度：500 + 400 - 600 = 300 left的位重为：2 * 500 = 1000 left + right的位重和为： 2 * 500 + 1 * 400 = 1400 left的宽度：500 - 1000/1400*300 = 285.72 若容器有多余宽度
容器多余宽度：容器的宽度 - 子元素原始宽度之和 子元素位重比：子元素位重grow / 所有子元素位重grow之和 子元素的宽度：子元素原始宽度 + 子元素位重比 * 容器多余宽度 将上述题目中的css修改为：` flex-basis: initial;` 即： 超出容器宽度：600 - 0 = 600 left的位重比为：1 / (1 + 2) = 1/3 left的宽度：0 + 600*1/3 = 200 将上述题目中的css修改为：` flex-basis: 100px;` 即： 超出容器宽度：600 - 200 = 400 left的位重比为：1 / (1 + 2) = 1/3 left的宽度：200 + 400*1/3 = 233.</description></item><item><title>前端系列：请求知识</title><link>https://linjiasen63.github.io/posts/programming/front/other/request-basic.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/other/request-basic.html</guid><description>一. XMLHttpRequest 对象 1. 初始化值 1.1 适用于ie7之前 function createXHR() { if (typeof arguments.callee.activeXString != &amp;#39;string&amp;#39;) { var versions = [&amp;#39;MSXML3.XMLHttp.6.0&amp;#39;, &amp;#39;MSXML3.XMLHttp.3.0&amp;#39;, &amp;#39;MSXML2.XMLHttp&amp;#39;]; for (var i = 0; i &amp;lt; versions.length; i++) { try { var version = versions[i]; new ActiveXObject(version); arguments.callee.activeXString = version; break; } catch (err) { // 跳过 } } } return new ActiveXObject(arguments.callee.activeXString); } 1.2 适用于ie7之后 var xhr = new XMLHttpRequest(); 1.3 适用于所有版本 function createXHR() { if (typeof XMLHttpRequest != &amp;#39;undefined&amp;#39;) { return new XMLHttpRequest(); } else if (typeof ActiveXObject != &amp;#39;undefined&amp;#39;) { if (typeof arguments.callee.activeXString != &amp;#39;string&amp;#39;) { var versions = [&amp;#39;MSXML3.XMLHttp.6.0&amp;#39;, &amp;#39;MSXML3.XMLHttp.3.0&amp;#39;, &amp;#39;MSXML2.XMLHttp&amp;#39;]; for (var i = 0; i &amp;lt; versions.</description></item><item><title>在类liunx下用ansible编解码文件</title><link>https://linjiasen63.github.io/posts/programming/base/linux/ansible-basic-usage.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/base/linux/ansible-basic-usage.html</guid><description>1. 安装 brew install ansible 2. 使用 编码方式：AES256
# 加密 # ansible-valut encrypt ${filePath} # 需要输入两次密码 # 解密 # ansible-valut decrypt ${filePath}</description></item><item><title>在类liunx下用expect自动执行脚本</title><link>https://linjiasen63.github.io/posts/programming/base/linux/auto-execute-bash.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/base/linux/auto-execute-bash.html</guid><description>功能：代替人工进行交互式操作
1. 安装 brew install expect 2. 指令 # 1,1 创建脚本文件 echo &amp;#39;&amp;#39; &amp;gt; mine.sh # 1.2 赋予执行权限 chomd a+x mine.sh # 2. 编辑脚本文件 # 2.1 # spawn 执行支持的脚本命令 # spawn mysql.server status # 2.2 # expect 等待spawn处理结果 # 如下 # expect { # # 正式匹配 # &amp;#34;*SUCCESS*&amp;#34; { # } # # 正式匹配 # &amp;#34;*ERROR*&amp;#34; { # } # } # 2.3 set设置变量 # set name tom # 2.4 send_user模拟用户输入 # send_user ${shell命令} # 2.5 结束交互时不退出shell # interact 2.1 实例 #!/usr/bin/expect set password ~0322linQ #检查mysql的运行状态 spawn mysql.server status expect { # 已经启动 &amp;#34;*SUCCESS*&amp;#34; { send_user &amp;#34;mysql is runing!\n&amp;#34; spawn mysql -uroot -p expect &amp;#34;*password*&amp;#34; send &amp;#34;$password\r&amp;#34; } # 没有启动 &amp;#34;*ERROR*&amp;#34; { send_user &amp;#34;going to start mysql!</description></item><item><title>基于js的正则表达式入门教程</title><link>https://linjiasen63.github.io/posts/programming/base/regexp/tutorial-basic.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/base/regexp/tutorial-basic.html</guid><description>参考资料 正则极简教程，再也不会学了忘 # 结构：/pattern/flag # pattern = 模式 # flag = 标识符 1. 精确匹配（标识符） 标识符
i : 忽略大小写 g : 全局查找 m : 多行查找 u : 支持unicode 2. 横向模糊匹配 /p{m, n}/ * : { 0, } 匹配0个或多个 + : { 1, } 匹配1个或多个 ? : { 0, 1 } 匹配0个或1个 有两个含义：1. 惰性模式 2. 量词；区分方法：量词之后的?才表示惰性匹配 { m } : { m, m } 匹配m个 3. 纵向模糊匹配 // 匹配 apple或Apple /[aA]pple/ 3.1 简写形式 . 等价于 [^\n\r\u2018\u2029] \d 等价于 [0-9] \D 等价于 [^0-9] \w 等价于 [0-9a-zA-Z_] \W 等价于 [^0-9a-zA-Z_] \s 等价于 [\t\v\n\r\f]；表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符等。记忆方式：s是space character的首字母 \S 等价于 [^\t\v\n\r\f]；表示非空白字符 4. 位置 ^ : 文本开头 $ : 文本结尾 \b : 单词边界（一边是单词字符，一边是非单词字符） \B : 非单词边界（两边要不都是单词字符，要不都是非单词字符） (?</description></item><item><title>快速掌握Linux基本命令</title><link>https://linjiasen63.github.io/posts/programming/base/linux/bash-usage-basic.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/base/linux/bash-usage-basic.html</guid><description>1. 命令组成原则 # 命令名称 [-命令选项...] 命令参数 # 如 ls -l 2. 文件处理命令 2.1 目录命令 ls # -l --long的简写，展示具体信息 # -a --all的简写，展示所有内容 # -d 展示指定文件夹的信息 # -i 输出文件在系统中唯一的id信息 # -h 人性化输出（如将文件大小自动转换为KB、MB等） mkdir # 全称：make directories # -p 创建指定路径中不存在的目录 # 其中tmp目录不存在 mkdir -p ./tmp/200606 cd # 全称：change directories # cd 指定路径 cd .. cd /root cd ./tmp/200606 pwd # 全称：print working directories # 输出当前目录 pwd rmdir # 全称：remove empty directories # 删除空目录 rm # 全称：remove empty # 删除文件 # -r 删除目录 # -f 强制删除，不会二次询问 cp # -r 拷贝目录 cp -r ./tmp/200606 ./ mv # 移动与重命名 mv ./tmp/200606 ./2006 2.2 文件命令 # 退出：q touch、echo # touch 文件名 touch 1.</description></item><item><title>日常工作中关于Linux常用命令的汇总</title><link>https://linjiasen63.github.io/posts/programming/base/linux/job-bash-usage.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/base/linux/job-bash-usage.html</guid><description>1. 文件传输 参考链接
scp 本地复制到远程 远程复制到本地 两个远程之间复制 scp source&amp;lt;当前文件位置&amp;gt; destination&amp;lt;文件要复制到的位置&amp;gt;
远程文件位置的描述：${用户}@${ip地址或域名}:${文件的绝对路径}，如：root@linjiasen.com:/root/tmp/helloworld.txt
# 将远程服务器的文件 拷贝到本地 scp root@linjiasen.com:/root/tmp/helloworld.txt . # 如果没有配置免密，需要输入密码 拷贝文件夹 添加参数 -r
scp -r root@linjiasen.com:/root/tmp/ .</description></item><item><title>归档</title><link>https://linjiasen63.github.io/archives.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/archives.html</guid><description/></item><item><title>搜索</title><link>https://linjiasen63.github.io/search.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/search.html</guid><description/></item></channel></rss>
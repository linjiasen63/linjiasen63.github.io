<!doctype html><html class=theme-light><head lang=zh-cn><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=description content="生活足迹"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=keyword content><link rel="shortcut icon" href=/image/favicon.ico type=image/x-icon></link><title>java基础系列：语法基础</title><link rel=canonical href=/><link href=/scss/index.min.e14f6c4a755759a9fa87e27fa13d9356d25bc5216d22b89643b8f9babecf89b9.css rel=stylesheet><script type=text/javascript src=/js/jquery.min.js></script><link rel=stylesheet href=/gitalk/gitalk.css><script src=/gitalk/gitalk.min.js></script></head><body><header class=site-header><div class=site-wrapper><nav class=site-navbar><a class=site-navbar-brand href=/>林三木</a><div class=site-navbar-menu onclick=toggleNavbarmenu(this)><div class=icon></div></div><div class=site-navbar-collapse id=site-navbarText onclick=toggleNavbarmenu(this)><span class="site-navbar-text none"></span><ul class=site-navbar-nav><li class=nav-item><a class=nav-link href=/archives.html>归档</a></li><li class=nav-item><a class=nav-link href=/about.html>我的</a></li><li class=nav-item><a class=nav-link href=/>首页</a></li></ul></div></nav><script>function toggleNavbarmenu(c){var a=$(c).parent(),b='site-navbar-open';a.hasClass(b)?a.removeClass(b):a.addClass(b)}</script></div></header><div class=site-body><div class="site-wrapper clearfix"><main class=site-main><div class=site-main-wrapper><div class=single-post><div><article id=content class=md-render><h1 id=title class=title>java基础系列：语法基础</h1><h2>目录</h2><nav id=TableOfContents><ul><li><a href=#1-计算机通识>1. 计算机通识</a><ul><li><a href=#11-进制转换>1.1 进制转换</a></li><li><a href=#12--存储单位>1.2 存储单位</a></li><li><a href=#13-java简介>1.3 Java简介</a></li></ul></li><li><a href=#2-基本语法>2. 基本语法</a><ul><li><a href=#21-helloworld>2.1 HelloWorld</a></li><li><a href=#22--数据类型>2.2 数据类型</a></li><li><a href=#23-基本运算符>2.3 基本运算符</a></li><li><a href=#24-流程的控制>2.4 流程的控制</a></li><li><a href=#25-方法的简介>2.5 方法的简介</a></li><li><a href=#26-项目结构>2.6 项目结构</a></li></ul></li><li><a href=#3-内存分区>3. 内存分区</a><ul><li><a href=#31-栈stack>3.1 栈（stack)</a></li><li><a href=#32-堆heap>3.2 堆（heap)</a></li><li><a href=#33-方法区method-area>3..3 方法区（Method Area）</a></li><li><a href=#34-本地方法栈native-method-stack>3.4 本地方法栈（Native Method Stack）</a></li><li><a href=#35-寄存器pc-register>3.5 寄存器（PC Register）</a></li></ul></li><li><a href=#4-面向对象>4. 面向对象</a><ul><li><a href=#41-封装>4.1 封装</a></li><li><a href=#42-继承>4.2 继承</a></li><li><a href=#43-多态>4.3 多态</a></li><li><a href=#44-向上下转型>4.4 向上/下转型</a></li></ul></li><li><a href=#5-额外信息>5. 额外信息</a><ul><li><a href=#51--包装类>5.1 包装类</a></li><li><a href=#52-关键字>5.2 关键字</a></li><li><a href=#53-内部类>5.3 内部类</a></li></ul></li><li><a href=#6-基础接口>6 基础接口</a><ul><li><a href=#61-键盘输入与随机数>6.1 键盘输入与随机数</a></li><li><a href=#62-可变数组与arrays>6.2 可变数组与Arrays</a></li><li><a href=#63-math与objects>6.3 Math与Objects</a></li><li><a href=#64-string>6.4 String</a></li></ul></li></ul></nav><h2 id=1-计算机通识>1. 计算机通识</h2><h3 id=11-进制转换>1.1 进制转换</h3><ul><li>辗转相除法（十进制转换为其它进制）</li><li>位权累加法（其它进制转换为十进制）</li></ul><h3 id=12--存储单位>1.2 存储单位</h3><ul><li>1bit = 位（表示0或1）</li><li>1Byte = 8bit （数据存储的最小单元）</li><li>1KB = 1024Byte</li><li>1MB = 1024KB</li><li>1GB = 1024MB</li><li>1TB = 1024GB</li><li>1PB = 1024TB</li><li>&mldr;</li></ul><h3 id=13-java简介>1.3 Java简介</h3><p>95年发布，已有20来年的历史。目前大部分公司使用的主要版本还是java8。</p><p>java编写的程序是跨平台的，但是JVM是非跨平台的（每种平台都有各自版本的JVM）</p><ul><li>JDK = 编译器等开发工具 + JRE；</li><li>JRE = 运行类库 + JVM；</li></ul><h4 id=131-dos>1.3.1 DOS</h4><ul><li>盘符切换，如：<code>D:</code> (${磁盘标识}:)</li><li>切换目录 cd</li><li>清除 cls （全写：clear screen）</li><li>退出 exit</li></ul><h4 id=132-安装>1.3.2 安装</h4><ul><li>配置JAVA_HOME</li><li>配置PATH</li></ul><p>mac下无需如此，开发配置简单。</p><h4 id=133-jshell>1.3.3 jshell</h4><p>从java9开始支持</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:green># 进入</span>
jshell
<span style=color:green># 退出</span>
/exit
</code></pre></div><h2 id=2-基本语法>2. 基本语法</h2><h3 id=21-helloworld>2.1 HelloWorld</h3><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:green>// public的类名必须与文件名大小写一致
</span><span style=color:green></span><span style=color:#00f>public</span> <span style=color:#00f>class</span> <span style=color:#2b91af>HelloWorld</span> {
  <span style=color:green>// 程序的执行入口
</span><span style=color:green></span>  <span style=color:#00f>public</span> <span style=color:#00f>static</span> <span style=color:#2b91af>void</span> main(String[] args) {
    System.out.println(<span style=color:#a31515>&#34;Hello world!&#34;</span>);
  }
}
</code></pre></div><p><strong>执行过程：</strong></p><ol><li>编写源码文件（.java），如：HelloWorld.java</li><li>编译器编译生成字节码文件（.class），如：javac HelloWorld.java</li><li>jvm执行字节码文件，如：java HelloWorld.java</li></ol><h4 id=211-注释>2.1.1 注释</h4><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:green>// 单行注释
</span><span style=color:green></span>
<span style=color:green>/*
</span><span style=color:green>  多行的注释
</span><span style=color:green>*/</span>

<span style=color:green>/* 多行注释 */</span>
</code></pre></div><h4 id=212-关键字与标识符>2.1.2 关键字与标识符</h4><ul><li>关键字：预先定义，用于特定用途的，如public、class等；</li><li>标识符：<ul><li>由大小写字母（a-zA-Z）、数字（0-9）、美元符号（$）、下划线（_）组成；</li><li>不能以数字开头；</li><li>不能是关键字</li></ul></li></ul><h3 id=22--数据类型>2.2 数据类型</h3><h4 id=221-基本数据类型>2.2.1 基本数据类型</h4><p>4类8种</p><ul><li>整型<ul><li>byte：一个字节</li><li>short：二个字节</li><li>int：四个字节（默认）</li><li>long：八个字节</li></ul></li><li>浮点型<ul><li>float：四个字节</li><li>double：八个字节（默认）</li></ul></li><li>布尔型：<ul><li>只有两个值 true或false</li><li>boolean：一个字节</li></ul></li><li>字符型：<ul><li>如&rsquo;A'、&lsquo;B&rsquo;</li><li>char：两个字节</li></ul></li></ul><p><strong>注意事项：</strong></p><ol><li>long类型赋值时需要在常量后面加上“L”或“l”；float类型赋值时需要在常量后面加上“F”或“f”；</li><li>byte与short赋值时不能超过其值范围</li><li>字节大小与值范围没有直接关联，如float类型能表示的最大值超过long类型</li><li>浮点数都是近似数，精度有限，如用浮点数没精确法表示1/3</li></ol><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:green>// long类型在赋值时需要在当前值后面加上“L”作标识
</span><span style=color:green></span><span style=color:#2b91af>long</span> numLong = 1L;
<span style=color:green>// float类型在赋值时需要在当前值后面加上“F”作标识
</span><span style=color:green></span><span style=color:#2b91af>float</span> numFloat = 1.0F;

<span style=color:green>// 编译器类型转换优化
</span><span style=color:green></span><span style=color:#2b91af>short</span> s = 1;
<span style=color:green>// 如果byte、short、char右侧的值没有超过范围，编辑器会自动进行强制类型转换
</span><span style=color:green></span>
<span style=color:#2b91af>short</span> s1 = 1;
<span style=color:#2b91af>short</span> s2 = 2;
<span style=color:green>// short s3 = s1 + s2; // 编译不通过
</span><span style=color:green>// 编译器常量优化
</span><span style=color:green></span><span style=color:#2b91af>short</span> s4 = 1 + 2; <span style=color:green>// 编译器会将所有常量的计算提前进行（只有不存在变量）
</span></code></pre></div><h4 id=222-引用数据类型>2.2.2 引用数据类型</h4><ul><li>字符串</li><li>数组</li><li>类</li><li>接口</li><li>lamada</li></ul><h5 id=2221-数组>2.2.2.1 数组</h5><ul><li>引用类型</li><li>长度固定</li><li>只能存储固定的一种类型</li></ul><p>引用类型：传参、返回值时传递的都是地址值</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:green>// 1. 动态初始化：内容不确定时使用
</span><span style=color:green>// 1.1 数据类型[] 数组名称 = new 数据类型[数组长度]
</span><span style=color:green></span><span style=color:#2b91af>int</span>[] arr11 = <span style=color:#00f>new</span> <span style=color:#2b91af>int</span>[10];

<span style=color:green>// 2. 静态初始化：内容已确定时使用
</span><span style=color:green>// 2.1 数据类型[] 数组名称 = new 数据类型[] { 元素1, 元素2, ... };
</span><span style=color:green></span><span style=color:#2b91af>int</span>[]arr21 = <span style=color:#00f>new</span> <span style=color:#2b91af>int</span>[]{1, 2, 3, 4};
<span style=color:green>// 2.2 数据类型[] 数组名称 = new 数据类型[数组长度];
</span><span style=color:green></span><span style=color:#2b91af>int</span>[]arr22 = {1, 2, 3, 4};

<span style=color:green>// 输出的是数组的内存地址值：hash
</span><span style=color:green></span>System.out.println(arr21);
<span style=color:green>// 输出第几个元素的值：数组名[元素位置]
</span><span style=color:green></span>System.out.println(arr21[0]);
<span style=color:green>// 动态初始化时，其中的元素会被赋为零值
</span><span style=color:green></span>System.out.println(arr11[0]);
<span style=color:green>// 静态初始化时，同样会被赋为零值，然后立即被赋值
</span><span style=color:green></span>
<span style=color:green>// 数组的长度一经初始化就不可改变
</span><span style=color:green></span>System.out.println(arr11.length);
</code></pre></div><p>常见问题</p><ul><li>ArrayIndexOutOfBoundsException：数组索引越界异常</li><li>NullPointerExpection：空指针异常</li></ul><h4 id=223-零值>2.2.3 零值</h4><ul><li>整数类型：0</li><li>浮点数类型：0.0</li><li>字符类型：'\u0000'</li><li>布尔类型：false</li><li>引用类型：null</li></ul><h4 id=224-变量与常量>2.2.4 变量与常量</h4><ul><li>常量：程序运行过程中不能修改</li><li>变量：程序运行过程中可以修改</li></ul><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:green>// 1. 声明： 数据类型 变量名称;
</span><span style=color:green></span><span style=color:#2b91af>int</span> num;
<span style=color:green>// 2. 赋值：变量名称 = 具体值;
</span><span style=color:green></span>num = 1;
<span style=color:green>// 3. 声明 + 赋值：数据类型 变量名称 = 具体值;
</span><span style=color:green></span><span style=color:#2b91af>int</span> num = 1;
</code></pre></div><p><strong>注意事项</strong></p><ul><li>未赋值的变量不能使用，否则会报错</li></ul><p><strong>类型转换</strong></p><ul><li>自动类型转换（隐式）</li><li>强制类型转换（显式）</li></ul><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#2b91af>byte</span> numByte1 = 0;
<span style=color:green>// 自动类型转换（将范围小的数据类型转换为范围大的数据类型）
</span><span style=color:green></span><span style=color:#2b91af>short</span> numShort = numByte1;
<span style=color:#2b91af>float</span> numFloat = 100L

<span style=color:green>// 强制类型转换（将范围大的数据类型转换为范围小的数据类型）
</span><span style=color:green>// 可能会发生 “数据溢出” 或 “精度损失”
</span><span style=color:green>// 非必要情况下不建议使用。
</span><span style=color:green></span><span style=color:#2b91af>byte</span> numByte2 = (<span style=color:#2b91af>byte</span>) numShort;
<span style=color:#2b91af>int</span> numInt1 = 1000;
<span style=color:#2b91af>byte</span> numByte3 = (<span style=color:#2b91af>byte</span>) numInt1; <span style=color:green>// -24，数据溢出
</span><span style=color:green></span><span style=color:#2b91af>int</span> numInt2 = (<span style=color:#2b91af>int</span>) 3.5; <span style=color:green>// 3，精度损失
</span><span style=color:green></span>
<span style=color:green>// byte、short、char可以发生数学运算，例如：“+”，在运算时先提升为int类型再进行计算
</span><span style=color:green></span><span style=color:#2b91af>char</span> ch1 = <span style=color:#a31515>&#39;A&#39;</span>;
System.out.println(ch1 + 1); <span style=color:green>// 66
</span><span style=color:green></span>
<span style=color:green>// boolean不能发生数据类型转换
</span></code></pre></div><h4 id=225-ascii码表>2.2.5 ASCII码表</h4><ul><li>0x30 => 对应 0 (十进制值:48)</li><li>0x41 => 对应 A (十进制值:65)</li><li>0x61 => 对应 a (十进制值:97)</li></ul><h3 id=23-基本运算符>2.3 基本运算符</h3><ul><li>算术<ul><li>+、-、* 、/、%</li><li><code>++</code>、<code>--</code>（前自增/减、后自增/减）</li></ul></li><li>赋值<ul><li>=</li><li>+=、-=、*=、/=、%=（隐含强制类型转换）</li></ul></li><li>比较<ul><li>>、>=、&lt;、&lt;=、==、!=</li></ul></li><li>逻辑（参与运算的、结果都是boolean类型）<ul><li>&&</li><li>||</li><li>！</li><li>&& 或 || 短路（即如果根据左边表达式的值，已经能够知道最终结果，右边的表达式不会执行）</li></ul></li><li>三元</li></ul><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:green>// 赋值运算符+=、-=、*=、/=、%= 隐含强制类型转换；
</span><span style=color:green></span><span style=color:#2b91af>short</span> num = 5
num += 5;
<span style=color:green>// 等价于 num = (short) num + 5;
</span><span style=color:green></span> 
<span style=color:green>// 三元运算符：需要三个数据才可进行的运算。
</span><span style=color:green>// 数据类型 变量名称 = 条件判断 ？ 表达式A : 表达式B;
</span><span style=color:green></span><span style=color:#2b91af>int</span> num = 1 &gt; 100 ? 1 : 100;
<span style=color:green>// 变量的数据类型 需要 与表达式A、表达式B的数据类型对应
</span><span style=color:green></span>System.out.println(1.5 &gt; 100 ? 1.5 : 100;)
</code></pre></div><p><strong>“+”的三种用法：</strong></p><ul><li>数值相加</li><li>字符类型运算（转换成int进行相加）</li><li>字符串的运算（字符串连接）</li></ul><p>算术运行符中，自增/减运行符（++/&ndash;）在“单独作使用”（如<code>i++</code>），运行符前后顺序没有影响，而在“混合使用”（如<code>int j = ++i</code>）这两种情况有所区别，“前自增/减”会先修改变量的值再处理其它操作；而“后自增/减”会先处理其它操作再修改变量的值</p><h3 id=24-流程的控制>2.4 流程的控制</h3><ul><li>顺序结构</li><li>选择结构<ul><li>if / if&mldr;else / if&mldr;else if&mldr;else</li><li>switch</li></ul></li><li>循环结构<ul><li>for / while / do&mldr;while</li></ul></li></ul><h4 id=241-if>2.4.1 if</h4><pre><code class=language-code data-lang=code>if (关系表达式) {
  语句体;
}
</code></pre><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#2b91af>int</span> age = 15;
<span style=color:#00f>if</span> (age &gt; 30) {
  Sytem.out.println(<span style=color:#a31515>&#34;中年&#34;</span>);
} <span style=color:#00f>else</span> <span style=color:#00f>if</span> (age &gt; 18) {
  Sytem.out.println(<span style=color:#a31515>&#34;青年&#34;</span>);
} <span style=color:#00f>else</span> {
  Sytem.out.println(<span style=color:#a31515>&#34;少年&#34;</span>);
}
</code></pre></div><h4 id=242-switch>2.4.2 switch</h4><pre><code class=language-code data-lang=code>switch(表达式) {
  case 常量值1:
    语句体1;
    break;
  case 常量值2:
    语句体2;
    break;
  ...
  default:
    语句体n + 1;
    break;
}
</code></pre><ul><li>向下执行直到遇到break，或结束</li><li>switch中case的条件唯一（不能重复），否则编译不通过</li><li>表达式的结果只能是：<ul><li>基本数据类型中的byte、short、int、chart</li><li>引用数据类型中的String、emnum枚举</li></ul></li><li>case顺序可以随机，break可以省略（向下继续执行）</li></ul><h4 id=243-循环>2.4.3 循环</h4><pre><code class=language-code data-lang=code>执行流程：
  1.初始化表达式
  2.条件判断（布尔表达式）
  3.循环体
  4.步进表达式


for (初始化表达式; 条件判断; 步进表达式) {
  循环体;
}


初始化表达式
while (条件判断) {
  循环体;
  步进表达式;
}


初始化表达式
do {
  循环体;
  步进表达式;
} while (条件判断);
</code></pre><ul><li>次数确定多用for循环，次数不定多用while循环；</li><li>在条件判断为false的情况下，do&mldr;while还会执行一次；</li></ul><h5 id=1-循环控制语句>1) 循环控制语句</h5><ul><li>break：打断循环</li><li>continue：继续下次循环</li></ul><h5 id=2-死循环>2). 死循环</h5><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#00f>for</span> (let i = 0; i &lt; 100;) {
  System.out.println(<span style=color:#a31515>&#34;Hello World!&#34;</span>);
}
</code></pre></div><h5 id=3-循环嵌套>3). 循环嵌套</h5><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#00f>for</span> (let i = 0; i &lt; 24; i++) {
  <span style=color:#00f>for</span> (let j = 0; i &lt; 60; j++) {
    System.out.println(i + <span style=color:#a31515>&#34;:&#34;</span> + j);
  }
}
</code></pre></div><h3 id=25-方法的简介>2.5 方法的简介</h3><p>定义：</p><pre><code class=language-code data-lang=code>修饰符 返回值类型 方法名(参数列表) {
  方法体
  return 返回值
}
</code></pre><p>示例如下：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#00f>public</span> <span style=color:#00f>static</span> <span style=color:#2b91af>void</span> main(String[] args) {
  System.out.println(<span style=color:#a31515>&#34;Hello World!&#34;</span>);
}
</code></pre></div><ul><li>在类中定义方法，</li><li>不能在方法中定义方法（即不能嵌套定义）</li></ul><h4 id=251-方法重载-overload>2.5.1 方法重载 Overload</h4><p>定义：</p><ul><li>方法名称相同</li><li>参数列表不同<ul><li>参数个数不同</li><li>参数类型不同</li><li>参数多类型顺序不同</li><li>与参数名称无关</li><li>与返回值类型无关</li></ul></li></ul><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#00f>public</span> <span style=color:#00f>static</span> <span style=color:#2b91af>byte</span> add(<span style=color:#2b91af>byte</span> b1, <span style=color:#2b91af>byte</span> b2) {
  <span style=color:#00f>return</span> (<span style=color:#2b91af>byte</span>) (b1 + b2);
}

<span style=color:#00f>public</span> <span style=color:#00f>static</span> <span style=color:#2b91af>short</span> add(<span style=color:#2b91af>short</span> b1, <span style=color:#2b91af>short</span> b2) {
  <span style=color:#00f>return</span> (<span style=color:#2b91af>short</span>) (b1 + b2);
}

<span style=color:#00f>public</span> <span style=color:#00f>static</span> <span style=color:#2b91af>int</span> add(<span style=color:#2b91af>int</span> b1, <span style=color:#2b91af>int</span> b2) {
  <span style=color:#00f>return</span> b1 + b2;
}

<span style=color:#00f>public</span> <span style=color:#00f>static</span> <span style=color:#2b91af>int</span> add(<span style=color:#2b91af>int</span> b1, <span style=color:#2b91af>int</span> b2, <span style=color:#2b91af>int</span> b3) {
  <span style=color:#00f>return</span> b1 + b2 + b3;
}

<span style=color:#00f>public</span> <span style=color:#00f>static</span> <span style=color:#2b91af>int</span> add(<span style=color:#2b91af>int</span> b1, <span style=color:#2b91af>long</span> b2) {
  <span style=color:#00f>return</span> (<span style=color:#2b91af>int</span>) (b1 + b2);
}

<span style=color:#00f>public</span> <span style=color:#00f>static</span> <span style=color:#2b91af>int</span> add(<span style=color:#2b91af>long</span> b1, <span style=color:#2b91af>int</span> b2) {
  <span style=color:#00f>return</span> (<span style=color:#2b91af>int</span>) (b1 + b2);
}
</code></pre></div><p><code>System.out.println</code>为什么可以接收多种类型的参数，因为其实现了多种类型的方法（即重载）。</p><h3 id=26-项目结构>2.6 项目结构</h3><pre><code class=language-mermaid data-lang=mermaid>graph LR
project--1:n--&gt; module --1:n--&gt; package
</code></pre><h2 id=3-内存分区>3. 内存分区</h2><h3 id=31-栈stack>3.1 栈（stack)</h3><ul><li>存放局部变量（方法参数、方法内部的变量）。</li><li>作用域：一旦超出，就立即从栈内存当中消失。</li><li>方法运行一定在栈中。</li></ul><h3 id=32-堆heap>3.2 堆（heap)</h3><ul><li>凡是new出来的东西，都在堆中。</li><li>堆内里面的东西都有一个地址值：16进制。</li><li>堆内存里面的数据都有默认值，其规则为2.2.3。</li><li>对象实例中的方法实际上是一个地址值，指向方法区。</li></ul><h3 id=33-方法区method-area>3..3 方法区（Method Area）</h3><ul><li>存储.class相关信息，包含方法的信息</li></ul><h3 id=34-本地方法栈native-method-stack>3.4 本地方法栈（Native Method Stack）</h3><ul><li>与操作系统相关</li></ul><h3 id=35-寄存器pc-register>3.5 寄存器（PC Register）</h3><ul><li>与CPU相关</li></ul><h2 id=4-面向对象>4. 面向对象</h2><ul><li>面向过程（关心步骤，一步步处理）</li><li>面向对象（寻找有功能的对象进行处理）</li></ul><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#2b91af>int</span>[] arr = { 10, 20, 30, 40, 50 };

<span style=color:green>// 面向过程
</span><span style=color:green></span>System.out.print(<span style=color:#a31515>&#34;[&#34;</span>);
<span style=color:#00f>for</span> (<span style=color:#2b91af>int</span> i = 0; i &lt; arr.length; i++) {
    String str = (i == arr.length - 1) ? <span style=color:#a31515>&#34;]&#34;</span> : <span style=color:#a31515>&#34;, &#34;</span>;
    System.out.print(arr[i] + str);
}
System.out.println();

System.out.println(<span style=color:#a31515>&#34;======================&#34;</span>);

<span style=color:green>// 面向对象
</span><span style=color:green></span>System.out.println(Arrays.toString(arr));
</code></pre></div><p>特性</p><ul><li>封装</li><li>继承</li><li>多态</li></ul><h3 id=41-封装>4.1 封装</h3><h4 id=411-类与对象的简介>4.1.1 类与对象的简介</h4><ul><li>类：属性和行为的集合，可以看成一类事物的模板，<strong>事物的描述，是抽象的</strong>。<ul><li>属性：事物的状态信息，如：猫的颜色、年龄、品种等，即成员变量</li><li>行为：事物能够做什么，如：猫能捉耗子、被主人撸等，即成员方法</li></ul></li><li>对象：<strong>事物的实例，是具体的</strong>。、</li></ul><h4 id=412-类的使用流程>4.1.2 类的使用流程</h4><ul><li>导包<ul><li>在同一文件夹下不需要声明式导包</li><li>java.lang包下的类不需要声明式导包</li></ul></li><li>创建<ul><li><code>Student stu = new Student();</code></li></ul></li><li>使用<ul><li>属性：<code>System.out.println(stu.age);</code></li><li>行为：<code>stu.getName();</code></li></ul></li></ul><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#00f>public</span> <span style=color:#00f>class</span> <span style=color:#2b91af>Student</span> {
  <span style=color:green>// 成员变量
</span><span style=color:green></span>  <span style=color:#00f>private</span> String name;
  <span style=color:#00f>public</span> <span style=color:#2b91af>int</span> age;
  <span style=color:#00f>private</span> <span style=color:#2b91af>boolean</span> live;

  <span style=color:green>// 构造方法
</span><span style=color:green></span>  <span style=color:#00f>public</span> Student() {
    System.out.println(<span style=color:#a31515>&#34;无参构造方法执行&#34;</span>);
  }

  <span style=color:#00f>public</span> Student(String name, <span style=color:#2b91af>int</span> age, <span style=color:#2b91af>boolean</span> live) {
    System.out.println(<span style=color:#a31515>&#34;有参构造方法执行&#34;</span>);
    <span style=color:#00f>this</span>.name = name;
    <span style=color:#00f>this</span>.age = age;
    <span style=color:#00f>this</span>.live = live;
  }

  <span style=color:#00f>public</span> <span style=color:#2b91af>void</span> setName(String name) {
    <span style=color:#00f>this</span>.name = name;
  }

  <span style=color:#00f>public</span> <span style=color:#2b91af>int</span> getName() {
    <span style=color:#00f>return</span> name;
  }

  <span style=color:#00f>public</span> <span style=color:#2b91af>void</span> setLive(<span style=color:#2b91af>boolean</span> live) {
    <span style=color:#00f>this</span>.live = live;
  }

  <span style=color:#00f>public</span> <span style=color:#2b91af>void</span> isLive() {
    <span style=color:#00f>return</span> live;
  }
}
</code></pre></div><p>使用private可限制外界对成员变量的直接操作，然后提供setXxx以及getXxx的public方法供外界使用，可在方法中进行数据校验等。<strong>然而对于boolean类型的成员变量其get方法格式必须为isXxxx。</strong></p><p>当方法局部变量与成员变量时会优先使用局部变量（离得近），此时可使用this.xxx声明式的使用成员变量，其中xxx为成员变量名称。</p><p>通过谁调用的方法，谁就是this。</p><h4 id=413-成员变量与局部变量的区别>4.1.3 成员变量与局部变量的区别</h4><ul><li>定义位置：成员变量在类中，局部变量在方法中</li><li>作为域：成员变量在类，局部变量在方法</li><li>初始值：成员变量为零值，局部变量没有</li><li>内存位置：成员变量在堆中，局部变量在栈中</li><li>回收时间：成员变量当对象实例被垃圾回收时，局部变量当方法结束时</li></ul><h4 id=413-构造方法>4.1.3 构造方法</h4><ul><li>跟类名称完全一样（大小写严格）</li><li>不需要写返回值类型</li><li>不能return具体的返回值</li><li>如果没有声明构造方法，编译器会自动创建一个空参的构造参数；而一旦声明了，编辑器就不会自动创建。</li></ul><h4 id=414-一个标准的java类称为java-bean>4.1.4 一个标准的java类称为java bean</h4><ul><li>所有成员变量都使用private修饰</li><li>每个成员变量都在对应的getter与setter</li><li>存在一个无参构造方法</li><li>存在一个全参构造方法</li></ul><h3 id=42-继承>4.2 继承</h3><p>本质上就是：共性抽取。父类：基类、超类；子类：派生类。</p><ul><li>子类可拥有父类可继承的内容</li><li>子类还可拥有独有的内容</li></ul><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:green>// Employee.java
</span><span style=color:green></span><span style=color:#00f>public</span> <span style=color:#00f>class</span> <span style=color:#2b91af>Employee</span> {
  <span style=color:#00f>public</span> <span style=color:#2b91af>void</span> sayHello() {
    System.out.println(<span style=color:#a31515>&#34;Hello&#34;</span>);
  }
}

<span style=color:green>// Teacher.java
</span><span style=color:green></span><span style=color:#00f>public</span> <span style=color:#00f>class</span> <span style=color:#2b91af>Teacher</span> <span style=color:#00f>extends</span> Employee {
}

<span style=color:green>// Main.java
</span><span style=color:green></span><span style=color:#00f>public</span> <span style=color:#00f>class</span> <span style=color:#2b91af>Main</span> {
  <span style=color:#00f>public</span> <span style=color:#00f>static</span> <span style=color:#2b91af>void</span> main(String[] args) {
    Teacher t = <span style=color:#00f>new</span> Teacher();
    t.sayHello();
  }
}
</code></pre></div><h4 id=421-访问规则>4.2.1 访问规则</h4><p>父类不知道有哪些子类，只有子类才通知父类是谁</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:green>// 1. 直接通过子类对象访问成员变量：等号左边是谁，就优先使用谁，没有就向上找，最终没有就编译报错。
</span><span style=color:green>// 2. 间接通过成员方法访问成员变量：该方法属于谁，就优先用谁的，没有就向上找，最终没有就编译报错。
</span></code></pre></div><p>访问重名变量的规则</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:green>// 1. 局部变量：直接写
</span><span style=color:green>// 2. 本类的成员变量：this.xxx
</span><span style=color:green>// 3. 父类的成员变量：super.xxx
</span></code></pre></div><p>访问重名方法的规则</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:green>// 创建的对象是谁，就使用谁，没有就向上找，最终没有就编译报错。
</span></code></pre></div><h4 id=422-重写>4.2.2 重写</h4><ol><li>父子类之间：a.方法名称相同；b.参数列表相同</li><li>子类的返回值范围 必须小于或等于 父类的返回值范围</li><li>子类的方法权限 必须大于或等于父类的方法权限</li></ol><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:green>// Teacher.java
</span><span style=color:green></span><span style=color:#00f>public</span> <span style=color:#00f>class</span> <span style=color:#2b91af>Teacher</span> <span style=color:#00f>extends</span> Employee {
  <span style=color:green>// 可选的，但建议要加上，防止错误
</span><span style=color:green></span>  @Override
  <span style=color:#00f>public</span> <span style=color:#2b91af>void</span> sayHello() {
    <span style=color:green>// 重复利用父类的方法
</span><span style=color:green></span>    <span style=color:#00f>super</span>.sayHello();
    <span style=color:green>// 定义新的功能
</span><span style=color:green></span>    System.out.println(<span style=color:#a31515>&#34;你好&#34;</span>);
  }
}
</code></pre></div><p>Object类是所有类的公共最高类（祖宗类）</p><p>对于已经投入使用的类（生产环境），尽量不要进行修改。推荐定义一个新的类，来重复利用其中共性内容，并且添加新改动的内容。</p><h4 id=423-构造方法>4.2.3 构造方法</h4><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:green>// Employee.java
</span><span style=color:green></span><span style=color:#00f>public</span> <span style=color:#00f>class</span> <span style=color:#2b91af>Employee</span> {
  <span style=color:#00f>public</span> Employee() {
    System.out.println(<span style=color:#a31515>&#34;Employee&#34;</span>);
  }
}

<span style=color:green>// Teacher.java
</span><span style=color:green></span><span style=color:#00f>public</span> <span style=color:#00f>class</span> <span style=color:#2b91af>Teacher</span> <span style=color:#00f>extends</span> Employee {
  <span style=color:#00f>public</span> Teacher() {
    System.out.println(<span style=color:#a31515>&#34;Teacher&#34;</span>);
  }
}

<span style=color:green>// Main.java
</span><span style=color:green></span><span style=color:#00f>public</span> <span style=color:#00f>class</span> <span style=color:#2b91af>Main</span> {
  <span style=color:#00f>public</span> <span style=color:#00f>static</span> <span style=color:#2b91af>void</span> main(String[] args) {
    Teacher t = <span style=color:#00f>new</span> Teacher();
    System.out.println(t);
  }
}
</code></pre></div><ol><li>子类的构造方法中默认包含一个无参数父类构造方法调用，即<code>super();</code>，可以通过显示调用，覆盖默认行为（如父类没有无参构造方法时，使用<code>super(name);</code>）</li><li><code>super调用父类构造</code>必须是子类构造方法的第一行第一个语句，且只能调用一次</li></ol><ul><li>super用来访问父类内容<ul><li>在本类的成员方法中调用父类的成员变量：<code>super.name;</code></li><li>在本类的成员方法中调用父类的成员方法：<code>super.getName();</code></li><li>在本类的构造方法中调用父类的构造方法：<code>super();</code></li></ul></li><li>this用来访问本类内容<ul><li>在本类的成员方法中调用本类的成员变量：<code>this.name;</code></li><li>在本类的成员方法中调用本类的成员方法：<code>this.getName();</code></li><li>在本类的构造方法中调用本类的另一个构造方法（参数不同），必须是第一行第一个语句。使用<code>this();</code>后不会提供默认的<code>super()</code></li></ul></li><li>super和this不能同时使用</li></ul><h4 id=424-其它>4.2.4 其它</h4><p>内存中，堆中的子类对象实例包含一个父类对象实例，先建父类对象实例，再创建其它成员变量。</p><ul><li>java言语是<strong>单继承</strong>的（只能有一个直接父类）</li><li>可以多级继续（即可以有多个父类）</li><li>一个父类可以有多个子类（即1 : m）</li></ul><h4 id=425-抽象>4.2.5 抽象</h4><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:green>// 抽象方法所有的类一定是抽象类
</span><span style=color:green>// 抽象类不一定有抽象方法
</span><span style=color:green></span><span style=color:#00f>public</span> <span style=color:#00f>abstract</span> <span style=color:#00f>class</span> <span style=color:#2b91af>Animal</span> {
  <span style=color:#00f>private</span> String name;

  <span style=color:#00f>public</span> Animal() {
    <span style=color:green>// 抽象类可以有构造方法
</span><span style=color:green></span>  }

  <span style=color:green>// 抽类方法：父类不知道具体的实现
</span><span style=color:green></span>  <span style=color:#00f>public</span> <span style=color:#00f>abstract</span> <span style=color:#2b91af>void</span> eat();

 <span style=color:#00f>public</span> <span style=color:#2b91af>void</span> setName(String name) {
    <span style=color:#00f>this</span>.name = name;
  }

  <span style=color:#00f>public</span> String getName() {
    <span style=color:#00f>return</span> <span style=color:#00f>this</span>.name;
  }
}

<span style=color:#00f>public</span> <span style=color:#00f>class</span> <span style=color:#2b91af>Cat</span> <span style=color:#00f>extends</span> Animnal {
  <span style=color:#00f>public</span> <span style=color:#2b91af>void</span> eat() {
    System.out.println(<span style=color:#a31515>&#34;cat eat finish&#34;</span>);
  }
}
</code></pre></div><p>使用流程：</p><ul><li>抽象类不能直接创建实例</li><li>必须使用一个子类来继续抽象父类，并覆盖重写所有抽象方法</li><li>创建子类对象进行使用</li></ul><h3 id=43-多态>4.3 多态</h3><h4 id=431-接口>4.3.1 接口</h4><p>接口就是<strong>公共的规范标准</strong></p><ul><li>java7之前（包含），可以有以下内容<ul><li>常量</li><li>抽象方法</li></ul></li><li>java8，可以有java7的内容 + 以下内容<ul><li>默认方法</li><li>静态方法</li></ul></li><li>java9，可以有java8的内容 + 以下内容<ul><li>私有方法</li></ul></li></ul><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#00f>public</span> <span style=color:#00f>interface</span> <span style=color:#2b91af>AnimalImpl</span> {
  <span style=color:green>// 常量
</span><span style=color:green></span>  <span style=color:green>// [ public staitc final ] 数据类型 变量名 = 数据值;
</span><span style=color:green></span>  <span style=color:#00f>public</span> staitc <span style=color:#00f>final</span>  <span style=color:#2b91af>int</span> S_ID = 0;
  <span style=color:green>// 使用：接口名称.常量名，如 AnimalImpl.S_ID
</span><span style=color:green></span>  <span style=color:green>// 常量名称：完全大写字母 + 使用“_”进行分隔
</span><span style=color:green></span>
  <span style=color:green>// 抽象方法
</span><span style=color:green></span>  <span style=color:green>// [ public abstract ] 返回值类型 方法名称(参数列表);
</span><span style=color:green></span>  <span style=color:#00f>public</span> <span style=color:#00f>abstract</span> <span style=color:#2b91af>void</span> eat();

  <span style=color:green>// 默认方法
</span><span style=color:green></span>  <span style=color:green>// [ public ] default 返回值类型 方法名称(参数列表) {
</span><span style=color:green></span>  <span style=color:green>//   方法体
</span><span style=color:green></span>  <span style=color:green>// }
</span><span style=color:green></span>  <span style=color:green>// 解决接口升级的问题：接口Impl有两个实现类A、B，发布生产后，Impl增加一个方法定义，此时使用默认方法定义，而不需要修改类A、B的内容，
</span><span style=color:green></span>  <span style=color:green>// 可被接口实现类的实例间接调用，也可被覆盖重写
</span><span style=color:green></span>
  <span style=color:green>// 静态方法
</span><span style=color:green></span>  <span style=color:green>// [ public ] static 返回值类型 方法名称(参数列表) {
</span><span style=color:green></span>  <span style=color:green>//   方法体
</span><span style=color:green></span>  <span style=color:green>// }
</span><span style=color:green></span>  <span style=color:green>// 使用：接口名称.静态方法()。不能通过接口实现类对象调用静态方法，原因一个类可以实现多个接口。
</span><span style=color:green></span>
  <span style=color:green>// 私有方法：需要抽取一个方法，用来解决两个方法之间重复代码的问题，但这个公有方法不能让实现类使用。
</span><span style=color:green></span>  <span style=color:green>// 普通私有方法：解决两个默认方法重复代码
</span><span style=color:green></span>  <span style=color:green>// 静态私有方法：解决两个静态方法重复代码
</span><span style=color:green></span>  <span style=color:green>// private [ static ] 返回值类型 方法名称(参数列表) {
</span><span style=color:green></span>  <span style=color:green>//   方法体
</span><span style=color:green></span>  <span style=color:green>// }
</span><span style=color:green></span>}

<span style=color:#00f>public</span> <span style=color:#00f>class</span> <span style=color:#2b91af>Cat</span> <span style=color:#00f>implements</span> AnimalImpl {
  <span style=color:#00f>public</span> <span style=color:#2b91af>void</span> eat() {
    System.out.println(<span style=color:#a31515>&#34;cat eat finish&#34;</span>);
  }
}
</code></pre></div><p>接口当中的抽象方法，修饰符必须是两个固定的关键字：<code>public abstract</code>，可以选择性地省略。</p><p>接口没有静态代码块，没有构造函数。</p><p>使用流程：</p><ul><li>接口不能直接使用，必须有一个实现类来实现该接口</li><li>接口的实现必须覆盖重写所有的抽象方法</li><li>创建实现类对象</li></ul><p>如果没有覆盖重写所有抽象方法，那这个类必须是抽象类。</p><ul><li>可以实多实现（接口A、B），但需要覆盖重写接口A、B的抽象方法，否则为抽象类</li><li>如果接口A、B有重复的默认方法，实现类X一定要<strong>覆盖重写</strong>重复的默认方法</li><li>父类的方法 与 接口的默认方法 重复，会优先使用：<strong>父类的方法</strong>，继承优先于实现</li></ul><h5 id=4311-接口多继承>4.3.1.1 接口多继承</h5><ul><li>多个父接口的默认方法重复，子接口必须需要覆盖重写此方法（且带default）</li></ul><h4 id=432-多态>4.3.2 多态</h4><p>父类引用 指向 子类对象</p><ul><li>属性：编译看左边，运行看左边</li><li>行为：编译看左边，运行看右边</li></ul><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>AnimalImpl animal = <span style=color:#00f>new</span> Cat();
</code></pre></div><h3 id=44-向上下转型>4.4 向上/下转型</h3><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:green>// 向上转型：父类引用 指向 子类对象，一定是安全的
</span><span style=color:green>// 就没法调用子类的特有方法
</span><span style=color:green></span>AnimalImpl animal = <span style=color:#00f>new</span> Cat();

<span style=color:green>// 向下转型：
</span><span style=color:green>// 子类名称 对象名 = (子类名称) 父类对象
</span><span style=color:green>// 将子类对象，还原 成为本来的子类对象
</span><span style=color:green></span>Cat cat = (Cat) animal;

<span style=color:green>// 运行异常：ClassCaseException，animal本来就不是狗，强制转换为狗就会报错。
</span><span style=color:green></span>Dog dog = (Dog) animal;

</code></pre></div><h4 id=441--instanceof>4.4.1 instanceof</h4><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:green>// 格式：对象 instanceof 类型
</span><span style=color:green>// 返回结果boolean，判断前端的对象能不能当作类型的实例
</span><span style=color:green></span><span style=color:#00f>if</span> (animal <span style=color:#00f>instanceof</span> Cat) {
  Cat cat = (Cat) animal;
}
<span style=color:#00f>if</span> (animal <span style=color:#00f>instanceof</span> Dog) {
  Dog dog = (Dog) animal;
}
</code></pre></div><h2 id=5-额外信息>5. 额外信息</h2><h3 id=51--包装类>5.1 包装类</h3><table><thead><tr><th>基本类型</th><th>包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>chart</td><td>Character</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><p>包装类：引用类型，都位于java.lang包下</p><p>jdk1.5+ 支持自动装箱，自动拆箱</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:green>// 自动装箱：相当于Integer i1 = new Integer(1);
</span><span style=color:green></span>Integer i1 = 1;

<span style=color:green>// 自动拆箱
</span><span style=color:green></span><span style=color:#2b91af>int</span> sum = i1 + 2;
<span style=color:green>// i1是包装类，无法直接参与运算，可以自动转换为基本类型的数据，再进行计算。
</span><span style=color:green>// i1 + 2 相当于  i1.intValue() + 2;
</span></code></pre></div><h4 id=511-以integer为例>5.1.1 以Integer为例</h4><p>装箱</p><pre><code>// 构造方法（过期）
Integer(int value);
Integer(String s);

// 静态方法
Integer.valueOf(int value);
Integer.valueOf(String s);
</code></pre><p>拆箱</p><pre><code class=language-code data-lang=code>// 对象方法
Integer.intValue();
</code></pre><h3 id=52-关键字>5.2 关键字</h3><h4 id=521-权限修饰符>5.2.1 权限修饰符</h4><p>权限的范围</p><pre><code class=language-code data-lang=code>public &gt; protected &gt; （default，不是关键字，而是什么都不写） &gt; private
</code></pre><table><thead><tr><th></th><th>public</th><th>protected</th><th>default</th><th>private</th></tr></thead><tbody><tr><td>同类</td><td>YES</td><td>YES</td><td>YES</td><td>YES</td></tr><tr><td>同包</td><td>YES</td><td>YES</td><td>YES</td><td></td></tr><tr><td>不同包为子类</td><td>YES</td><td>YES</td><td></td><td></td></tr><tr><td>不同包非子类</td><td>YES</td><td></td><td></td><td></td></tr></tbody></table><p>private私有，修饰成员变量或成员方法时，表示只能在本类中被使用，在本类之外可以使用其它公有方法（<strong>public</strong>修饰）间接调用。</p><h4 id=522-静态修饰符>5.2.2 静态修饰符</h4><p>静态，修饰成员变量或成员方法时，表示其属于类，类的所有实例共用一份数据。</p><p>静态内容：推荐使用：<code>类名.静态方法()</code> / <code>类名.静态变量 = 10</code>，如<code>Person.StaticMethond();</code> 或 <code>Person.StaticNum = 10;</code>的方式调用。即使使用对象实例调用静态变量或静态方法，经过编译器编译器也会转换为类名的。对于本类当中的静态成员或静态方法可以省略类名。</p><ul><li>静态只能直接访问静态，不能访问非静态。（内存中先有静态内容，后有非静态内容）。</li><li>静态方法中不能使用this。这是因为：this代表当前对象，而静态内容优先于对象存在。</li></ul><p>内存介绍：
方法区中有一块区域，叫静态区，用于存放静态内容</p><p><strong>静态代码块</strong></p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#00f>public</span> <span style=color:#00f>class</span> <span style=color:#2b91af>Person</span> {
  <span style=color:#00f>static</span> {
    <span style=color:green>// 静态代码块的内容
</span><span style=color:green></span>    System.out.println(<span style=color:#a31515>&#34;一般用于执行初始化操作&#34;</span>);
  }
}
</code></pre></div><p>特点：当加本类的class文件到内存时（<code>Class.forName("com.linjiasen.basic.Person")</code>或<code>Person p = new Person();</code>），静态代码块执行<strong>唯一</strong>的一次。
静态的内容总是优先于非静态（静态代码块比构造方法先执行），所以静态代码比构造方法先执行。</p><p>用法：对静态变量进行初始化。</p><h4 id=523-final>5.2.3 final</h4><h5 id=5231-修饰类>5.2.3.1 修饰类</h5><pre><code class=language-code data-lang=code>public final class 类名 {
  ...
}
</code></pre><ul><li>被final修饰的类不能被继承</li></ul><h5 id=5232-修饰方法>5.2.3.2 修饰方法</h5><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#00f>public</span> <span style=color:#00f>class</span> <span style=color:#2b91af>Super</span> {
  <span style=color:green>// 修饰符 final 返回值类型 方法名(参数列表)
</span><span style=color:green></span>  <span style=color:#00f>public</span> <span style=color:#00f>final</span> <span style=color:#2b91af>void</span> sayHello() {
    System.out.println(<span style=color:#a31515>&#34;Hello&#34;</span>);
  }
}

<span style=color:#00f>public</span> <span style=color:#00f>class</span> <span style=color:#2b91af>Sub</span> <span style=color:#00f>extends</span> {
  <span style=color:green>// 不能覆盖重写sayHello
</span><span style=color:green></span>}
</code></pre></div><p>被final修饰的方法不能被重写，因此不能与abstract共用，两者矛盾。</p><h5 id=5233-修饰局部变量>5.2.3.3 修饰局部变量</h5><p>一旦使用final修饰局部变量，那么这个变量不能进行更改，若是引用变量则是地址值不能变。</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#00f>public</span> <span style=color:#00f>static</span> <span style=color:#2b91af>void</span> main(String[] args) {
  <span style=color:#00f>final</span> <span style=color:#2b91af>int</span> num1 = 1;
  <span style=color:green>// 合法，只要只有一次赋值
</span><span style=color:green></span>  <span style=color:#00f>final</span> <span style=color:#2b91af>int</span> num2;
  num2 = 2;
}

</code></pre></div><h5 id=5234-修饰成员变量>5.2.3.4 修饰成员变量</h5><ul><li>由于成员变量具有默认值，所以用了final之后必须手动赋值，不会再给默认值</li><li>对于final的成员变量，要么直接赋值，要么通过构造方法赋值</li><li>必须保证类中所有重载的构造方法都对该成员变量进行赋值，若不行就直接赋值</li></ul><h3 id=53-内部类>5.3 内部类</h3><h4 id=531-成员内部类>5.3.1 成员内部类</h4><pre><code class=language-code data-lang=code>修饰符 class 外部类名称 {
  修饰符 class 内部类名称 {
    ...
  }
  ...
}
</code></pre><ul><li>内部类用外部类，随意使用；但外部类使用内部类，需要内部类对象</li></ul><p>使用内部类有以下方式：</p><ul><li>间接方式：在外部类的方法中，使用内部类；然后调用外部类的方法</li><li>直接方式：<code>外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();</code>，如<code>Body.Heart heart = new Body().new Heart();</code></li></ul><p>重名情况下，在内部类中使用外部类中的变量：<code>外部类名称.this.成员变量名称</code>，如<code>Body.this.name</code></p><h4 id=532-局部内部类>5.3.2 局部内部类</h4><p>定义在方法内部的类</p><pre><code class=language-code data-lang=code>修饰符 class 外部类名称 {
  修饰符 返回值类型 外部类方法名称(参数列表) {
    修饰符 class 内部类名称 {
      ...
    }
  }
  ...
}
</code></pre><p>类可以使用的修饰符</p><ol><li>外部类：pubic / (default)</li><li>成员内部类：public / protected / (default) / private</li><li>局部内部类：什么都不能写（跟（default）不同）</li></ol><p>局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是【有效final的（1. final修饰 2.事实不变（从java8开始））】</p><p>为什么局部变量必须是【有效final】的原因：</p><ol><li>new创建的对象是堆内存中</li><li>局部变量是跟方法走的，在栈内存中</li><li>方法运行结束之后，立刻出栈，局部变量就会被回收</li><li>但new创建的对象会在堆中持续存在，直到垃圾回收</li></ol><h5 id=5321-匿名内部类>5.3.2.1 匿名内部类</h5><p>如果接口的实现类、父类的子类只需要使用唯一的一次</p><pre><code class=language-code data-lang=code>接口名称 对象名 = new 接口名称() {
  // 覆盖重写所有抽象方法
}
</code></pre><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#00f>public</span> <span style=color:#00f>interface</span> <span style=color:#2b91af>USBImpl</span> {
  <span style=color:#00f>public</span> <span style=color:#00f>abstract</span> <span style=color:#2b91af>void</span> poweron();
}

<span style=color:green>// 匿名内部类
</span><span style=color:green></span>USBImpl usb = <span style=color:#00f>new</span> USBImpl() {
  @Override
  <span style=color:#00f>public</span> <span style=color:#2b91af>void</span> poweron() {
    System.out.printlnl(<span style=color:#a31515>&#34;power on&#34;</span>);
  }
}
</code></pre></div><h2 id=6-基础接口>6 基础接口</h2><h3 id=61-键盘输入与随机数>6.1 键盘输入与随机数</h3><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:green>// java.lang包下的类不需要引入
</span><span style=color:green></span><span style=color:#00f>import</span> java.util.Scanner;

Scanner scanner = <span style=color:#00f>new</span> Scanner(System.in);
<span style=color:#2b91af>int</span> num = scanner.nextInt();
</code></pre></div><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>Random random = <span style=color:#00f>new</span> Random();
<span style=color:green>// 生成0~9的随机数
</span><span style=color:green></span><span style=color:#2b91af>int</span> num = random.nextInt(10);
</code></pre></div><h3 id=62-可变数组与arrays>6.2 可变数组与Arrays</h3><h4 id=621--可变数组>6.2.1 可变数组</h4><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>ArrayList&lt;String&gt; arr = <span style=color:#00f>new</span> ArrayList&lt;String&gt;();
<span style=color:green>// 从jdk7开始，可简写为：
</span><span style=color:green>// ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
</span><span style=color:green>// 泛型只能是引用类型
</span><span style=color:green></span>
<span style=color:green>// 添加元素：返回值表示添加是否成功
</span><span style=color:green>// ArrayList添加一定成功，但其它集合不一定添加成功
</span><span style=color:green></span><span style=color:#2b91af>boolean</span> isOK1 = list.add(<span style=color:#a31515>&#34;小明&#34;</span>);
<span style=color:#2b91af>boolean</span> isOK2 list.add(<span style=color:#a31515>&#34;小红&#34;</span>);

<span style=color:green>// 获取元素
</span><span style=color:green></span>String first = list.get(0);

<span style=color:green>// 删除元素：返回值表示被删除的值
</span><span style=color:green></span>String deleteItem = list.remove(1);

<span style=color:green>// 获取集合的长度
</span><span style=color:green></span><span style=color:#2b91af>int</span> len = list.size();
</code></pre></div><h4 id=622--arrays>6.2.2 Arrays</h4><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:green>// public static void String toString()：转换为字符串
</span><span style=color:green>// public static void sort(T[] arr)：排序（Comparable接口与Comparator接口）
</span><span style=color:green></span><span style=color:#2b91af>int</span>[] arr = {1, 8, 10, 6};
System.out.println(Arrays.toString(arr));

<span style=color:green>// 1. 如果是数值，数值升序
</span><span style=color:green>// 2. 如果是字符串，字母升序
</span><span style=color:green>// 3. 如果是自定义类，自定义类需要实现Comparable或Comparator接口
</span><span style=color:green></span>Arrays.sort(arr);
System.out.println(arr);
</code></pre></div><h3 id=63-math与objects>6.3 Math与Objects</h3><h4 id=631--math>6.3.1 Math</h4><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#00f>public</span> <span style=color:#00f>static</span> T abs(T t)<span>：</span>取其绝对值
<span style=color:#00f>public</span> <span style=color:#00f>static</span> T ceil(T t)<span>：</span>向上取整
<span style=color:#00f>public</span> <span style=color:#00f>static</span> T floor(T t)<span>：</span>向下取整


<span style=color:#00f>public</span> <span style=color:#00f>static</span> T round(T t)<span>：</span>四舍五入
PI<span>：</span>近似的圆周率常量
</code></pre></div><h4 id=632--objects>6.3.2 Objects</h4><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:green>//  requireNonNull()：判断某个对象是否为空（为空会抛出空指针异常）
</span></code></pre></div><h3 id=64-string>6.4 String</h3><ul><li>字符串内容永不可变</li><li>共享使用</li><li>效果上相当于<code>char[]</code>，但底层原理是<code>byte[]</code></li></ul><h4 id=641-创建方法>6.4.1 创建方法</h4><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:green>// 直接创建
</span><span style=color:green></span>String str = <span style=color:#a31515>&#34;你好，世界！&#34;</span>

<span style=color:green>// 构造方法创建
</span><span style=color:green></span><span style=color:#00f>public</span> String(): 创建一个空白字符串
<span style=color:#00f>public</span> String(<span style=color:#2b91af>char</span>[] arr)<span>：</span>根据字符数组创建字符串
<span style=color:#00f>public</span> String(<span style=color:#2b91af>byte</span>[] arr)<span>：</span>根据字节数组创建字符串
</code></pre></div><p>程序中直接使用双引号定义的字符串，如<code>String str = "GOOD";</code>，就在<strong>字符串常量池</strong>中。</p><p>== 运算符的规则：</p><ul><li>对于基本类型来说，==是进行数值的比较</li><li>对于引用类型来说，==是进行地址值比较</li></ul><p>字符串常量池在堆中。字符串常量池中保存的是字符串的地址，而不是字符串的内容。字符串的内容还是存放在堆中，跟字符串常量池并列。</p><h4 id=642-常用方法>6.4.2 常用方法</h4><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:green>// 判断内容是否相同
</span><span style=color:green></span><span style=color:#00f>public</span> <span style=color:#2b91af>boolean</span> equals(Object obj)<span>：</span>区分大小写
<span style=color:#00f>public</span> <span style=color:#2b91af>boolean</span> equalsIgnoreCase(Object obj)<span>：</span>忽略大小写
  
<span style=color:#00f>public</span> <span style=color:#2b91af>int</span> length()<span>：</span>获取字符个数<span>，</span>即字符串长度
<span style=color:#00f>public</span> String concat(String str)<span>：</span>拼接字符串<span>（</span>返回新的字符串<span>）</span>
<span style=color:#00f>public</span> <span style=color:#2b91af>char</span> chartAt(<span style=color:#2b91af>int</span> index)<span>：</span>返回指定位置的字符
<span style=color:#00f>public</span> <span style=color:#2b91af>int</span> indexOf(String str)<span>：</span>返回指定字符串在本字符串首次出现的位置<span>，</span>如果不存在返回-1
  
<span style=color:green>// 截取
</span><span style=color:green></span><span style=color:#00f>public</span> String substring(<span style=color:#2b91af>int</span> index)<span>：</span>从参数开始到未尾
<span style=color:#00f>public</span> String substring(<span style=color:#2b91af>int</span> begin, <span style=color:#2b91af>int</span> end)<span>：</span>从begin开始<span>，</span>到end结束<span>，</span>中间的字符串<span>，</span>左闭右开

<span style=color:green>// 转换
</span><span style=color:green></span><span style=color:#00f>public</span> <span style=color:#2b91af>char</span>[] toCharArray()<span>：</span>获取字符串的字符数组
<span style=color:#00f>public</span> <span style=color:#2b91af>byte</span>[] getBytes()<span>：</span>获取字符串底层的字节数组
<span style=color:#00f>public</span> String replace(CharSquence oldString, CharSquence newString)<span>：</span>将**所有**出现的老字符串替换为新的字符串

<span style=color:green>// 分割
</span><span style=color:green></span><span style=color:#00f>public</span> String[] split(String regex)<span>：</span>按照参数<span>（</span>正则表达式<span>）</span>的规则<span>，</span>将字符串分成若干份<span>。</span>
</code></pre></div><p><code>a.equals(b)</code> 等价于 <code>b.equals(a)</code>。如果a为常量，建议使用为<code>a.equals(b)</code>，如<code>"你好，世界".equals(str)</code></p></article></div><div class=pagination-single><div class=btn>上一篇：<a class=previous href=https://linjiasen63.github.io/posts/programming/mysql/tutorial-basic.html>
60min入门mysql</a></div><div class=btn>下一篇：<a class=next href=https://linjiasen63.github.io/posts/programming/java/idea-keymap.html>
idea常用快捷键</a></div></div></div><div id=pageScrollTop class=page-scroll-top><span class=arr></span><span class=txt>顶部</span></div><script>var $pageScrollTop=$("#pageScrollTop");$pageScrollTop.hide(),$pageScrollTop.on('click',function(){$('html,body').animate({scrollTop:'0px'},300)}),$(document).scroll(function(){var a=$(document).scrollTop(),b=$(document).height();a>b*.2?$pageScrollTop.show():$pageScrollTop.hide()})</script></div></main><aside class=site-aside><section class=widget><form id=search action=https://linjiasen63.github.io/search.html method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=wd maxlength=20 placeholder=Search>
<input type=hidden name=sitesearch value=https://linjiasen63.github.io>
<button type=submit class="submit icon-search">搜索</button></form></section><section class=widget><h3 class=widget-title><a href=/>最新内容</a></h3><ul class=widget-list><li><a href=https://linjiasen63.github.io/posts/programming/front/other/form-request.html title=前端系列：浏览器直接常见请求>前端系列：浏览器直接常见请求</a></li><li><a href=https://linjiasen63.github.io/posts/programming/front/midro-front/basic-usgae.html title=前端系列：微前端介绍>前端系列：微前端介绍</a></li><li><a href=https://linjiasen63.github.io/posts/programming/front/nodejs/basic-usage.html title=前端系列：nodejs入门>前端系列：nodejs入门</a></li><li><a href=https://linjiasen63.github.io/posts/programming/perf/front-performance.html title=性能优化：前端能够做哪些事情？>性能优化：前端能够做哪些事情？</a></li><li><a href=https://linjiasen63.github.io/posts/programming/base/git/conventional.html title=git基础：规范式提交>git基础：规范式提交</a></li></ul></section><section class=widget><h3 class=widget-title><a href=/categories.html>内容分类</a></h3><ul class=widget-list><li><a href=https://linjiasen63.github.io/categories/algorithm.html>algorithm</a></li><li><a href=https://linjiasen63.github.io/categories/%E5%B0%8F%E6%95%85%E4%BA%8B.html>小故事</a></li><li><a href=https://linjiasen63.github.io/categories/%E5%B7%A5%E4%BD%9C.html>工作</a></li><li><a href=https://linjiasen63.github.io/categories/%E7%94%9F%E6%B4%BB.html>生活</a></li><li><a href=https://linjiasen63.github.io/categories/%E7%BC%96%E7%A0%81%E4%BA%BA%E7%94%9F.html>编码人生</a></li></ul></section><section class=widget><h3 class=widget-title><a href=/tags.html>内容标签</a></h3><ul class=widget-list><li><a href=https://linjiasen63.github.io/tags/algorithm.html>algorithm</a></li><li><a href=https://linjiasen63.github.io/tags/git.html>git</a></li><li><a href=https://linjiasen63.github.io/tags/java%E5%AD%A6%E4%B9%A0.html>java学习</a></li><li><a href=https://linjiasen63.github.io/tags/%E4%BA%BA%E9%99%85%E5%85%B3%E7%B3%BB.html>人际关系</a></li><li><a href=https://linjiasen63.github.io/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95.html>前端面试</a></li><li><a href=https://linjiasen63.github.io/tags/%E6%8A%80%E8%83%BD.html>技能</a></li></ul></section></aside></div></div><footer class=site-footer><div>&copy; 2021
<a href=https://linjiasen63.github.io>林三木的博客 By linjiasen63</a></div><script type=text/javascript src=/js/mermaid.min.js></script><script>Array.from(document.getElementsByClassName("language-mermaid")).forEach(function(a){a.parentElement.outerHTML=`<div class="mermaid">${a.innerText}</div>`}),mermaid.initialize({startOnLoad:!0}),setTimeout(function(){Array.from(document.getElementsByTagName("polygon")).forEach(function(b){var a=b.attributes.transform.nodeValue;a=a.replace(/\d\d*\.?\d*/ig,function(a){return console.log(a),a+'px'}),console.log(a,$(b)),$(b).css('transform','scaleY(0.68) '+a)})},100)</script><link href=/scss/footer.min.074ed8877e04297a38609ed9ab79872ef47e84798d125aca3e681bea23d211f5.css rel=stylesheet></footer></body></html>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 林三木的博客</title><link>https://linjiasen63.github.io/posts.html</link><description>Recent content in Posts on 林三木的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sun, 03 Jan 2021 20:35:46 +0000</lastBuildDate><atom:link href="https://linjiasen63.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>java基础系列：注解编程</title><link>https://linjiasen63.github.io/posts/programming/java/java-se/annotation.html</link><pubDate>Sun, 03 Jan 2021 20:35:46 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/java/java-se/annotation.html</guid><description>1. 基础 注解，又称元数据，jdk1.5之后引入的特性，与类、接口、枚举是同一层次。它可以声明在包、类、方法、局部变量、方法参数等的前面，用来对这些元素进行说明、注释
作用：
编写文档 代码分析 编译检查 2. 注解 @Override：检测方法是否继承父类（接口）的 @Deorecated：表示已过时 @SuppressWarnings：压制警告 一般传递参数all，即：@SuppressWarnings(&amp;ldquo;all&amp;rdquo;) 2.1 自定义注解 2.1.1 定义格式 本质上就是一个接口
元注解 public @interface 注解名称 { } public @interface MyAnnotation {} // 等价于下面的内容，即注解本质上就是一个接口（可通过反编译验证） public interface MyAnnotation extends java.lang.annotation.Annotation {} 2.1.2 约束条件 注解中属性的返回值只能是下列内容之一 基本数据类型 字符串 枚举 注解 以上类型数组 若定义了属性，则使用时必须给属性赋值 定义了属性，在使用时需要给属性赋值，除非定义时使用default关键字进行初始化。 如果只有一个属性需要赋值，且这个属性名称为value，那么可以省略为@MyAnnotation(&amp;quot;王大锤&amp;quot;) 数组赋值时使用{}包裹，如果只有一个值，则{}可省略 2.1.3 元注解 用于注解的注解
@Target：描述注解能作用的位置 TYPE：可以作用于类上 FIELD：可以作用于成员变量上 METHOD：可以作用于方法上 @Retention：描述注解能被保留的阶段 @Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，会被jvm使用 @Documented：描述注解是否能被抽取到api文档中 @Inherited：描述注解是否被子类继承 2.1.4 常用方法 // 获取Class对象的注解对象 public &amp;lt;A extends Annotation&amp;gt; A getAnnotation(Class&amp;lt;A&amp;gt; annotationClass) // 判断Class对象是否有指定的注解 public boolean isAnnotationPresent(Class&amp;lt;? extends Annotation&amp;gt; annotationClass) 2.</description></item><item><title>java基础系列：反射编程</title><link>https://linjiasen63.github.io/posts/programming/java/java-se/reflect.html</link><pubDate>Sun, 03 Jan 2021 20:00:45 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/java/java-se/reflect.html</guid><description>1. 基础 Student.java编译生成Student.class，然后通过类加载器将Student.class加载到内存中
public class Student { private int id; private String name; public Student() { } public Student(int id, String name) { this.id = id; this.name = name; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return &amp;#34;Student{&amp;#34; + &amp;#34;id=&amp;#34; + id + &amp;#34;, name=&amp;#39;&amp;#34; + name + &amp;#39;\&amp;#39;&amp;#39; + &amp;#39;}&amp;#39;; } } 1.1 获取Class对象 // 1 通过类的全路径字符串，可能抛出ClassNotFoundException // 多用于配置文件中 Class&amp;lt;Student&amp;gt; cls1 = (Class&amp;lt;Student&amp;gt;) Class.forName(&amp;#34;com.linjiasen.basic.Student&amp;#34;); // 2 通过类的class属性 // 多用于参数传递 Class&amp;lt;Student&amp;gt; cls2 = Student.</description></item><item><title>java基础系列：单元测试</title><link>https://linjiasen63.github.io/posts/programming/java/java-se/unit-test.html</link><pubDate>Sun, 03 Jan 2021 11:06:52 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/java/java-se/unit-test.html</guid><description>1. 通识知识 黑盒测试：不关注代码细节，只关注输入与输出是否符合预期。（一般不需要写代码） 白盒测试：关注代码的具体实现。 2. junit 建议：
测试用例 测试类名：&amp;ldquo;被测试的类名&amp;rdquo; + &amp;ldquo;Test&amp;rdquo;，如被测试的类为Calculator，那就叫做CalculatorTest 包名： xx.xx.xx.test，如：com.linjiasen.test 测试方法 方法名：&amp;ldquo;test&amp;rdquo; + &amp;ldquo;测试的方法名&amp;rdquo;，如测试方法为add，那就叫做testAdd 返回值：void 参数列表：空参 给方法加@Test 导入junit依赖 断言结果：红色失败，绿色成功。Assert.assertEquals() 2.1 代码实现 public class Calculator { /** * add * @param i * @param j * @return */ public int add(int i, int j) { return i + j; } /** * sub * @param i * @param j * @return */ public int sub(int i, int j) { return i - j - 1; } } public class CalculatorTest { private static Calculator c; @BeforeClass public static void beforeClass() { // 执行测试前的准备工作（如文件的初始化、数据库的连接操作等） System.</description></item><item><title>java基础系列：网络请求</title><link>https://linjiasen63.github.io/posts/programming/java/java-se/network-connect.html</link><pubDate>Fri, 01 Jan 2021 10:29:10 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/java/java-se/network-connect.html</guid><description>1. 通识 1.1 类型 C/S B/S 1.2 架构 应用层 传输层 网络层 链路层 数据链路层 物理层 1.3 协议 UDP：面向无链接。速度快，可能出现数据丢失，一般用于视频、音频。 TCP：面向链接。可靠，无差错的 1.4 三次握手 客户端发送链接请求 服务端回复请求 客户确认收到回复 1.5 其它 ipv4 ipv6 端口号由两个字节组成，在0~65535，期中0~1024之前的端口号已经被系统使用。
常用端口
80：默认 3306：mysql 1521：oracle 8080：tomcat 2. 基础内容 2.1 服务端 Server.java
public class Server { public static void main(String[] args) throws IOException { ServerSocket server = new ServerSocket(8888); Socket socket = server.accept(); InputStream is = socket.getInputStream(); byte[] bytes = new byte[1024]; int len = is.read(bytes); System.out.println(&amp;#34;服务端收到请求：&amp;#34; + new String(bytes, 0, len)); OutputStream os = socket.getOutputStream(); os.write(&amp;#34;你好&amp;#34;.getBytes()); socket.close(); } } 2.</description></item><item><title>前端面试系列：手写常见方法</title><link>https://linjiasen63.github.io/posts/programming/front/interview/coding-fn.html</link><pubDate>Wed, 30 Dec 2020 15:10:42 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/interview/coding-fn.html</guid><description>1. new 原生实现：new Fn(...args)；自定义实现：newSelf(Fn, ...args)；
实现步骤：
校验传入的参数（Fn，args）（通过Array.prototype.slice获取） 创建空对象obj 将obj.__proto__赋值为Fn.prototype，obj.constructor赋值为Fn 将obj作为上下文，执行Fn 如果Fn有返回值result，则返回result；否则返回对象obj function newSelf() { var fn = Array.prototype.shift.call(arguments); if (typeof fn != &amp;#39;function&amp;#39;) { throw new Error(&amp;#34;The first param of the newSelf must be a function!&amp;#34;); } var obj = {}; obj.__proto__ = fn.prototype; obj.constructor = fn; var result = fn.apply(obj, arguments); return typeof result === &amp;#39;object&amp;#39; ? result : obj; } function Person(name) { this.name = name; } // test case var p = newSelf(Person, &amp;#39;小红&amp;#39;); console.log(&amp;#39;person str: &amp;#39;, p); console.log(&amp;#39;instanceof: &amp;#39;, p instanceof Person); 2. instanceof 原生实现：left instanceof right；自定义实现：instanceOfSelf(left, right)
实现步骤：
校验参数：left以及right 的合法性 获取obj=left.__proto; proto=right.prototype; 若obj为null，则返回false; 若obj===proto为ture，则返回true; 否则obj赋值为obj.</description></item><item><title>java基础系列：输入输出</title><link>https://linjiasen63.github.io/posts/programming/java/java-se/intput-output.html</link><pubDate>Tue, 29 Dec 2020 23:34:31 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/java/java-se/intput-output.html</guid><description>1. File类 java.io.File，文件与目录的抽象表示形式
1.1 File的静态常量 // 与系统有关的路径分隔符 static String pathSeparator // 为方便，为字符串 static char pathSeparatorChar // mac: 冒号` :` // win: 分号` ;` // 与系统有关的默认名称分隔符 static String separator // 为方便，为字符串 static char separatorChar // mac: 正叙扛` /` // win: 反叙扛`\` 1.2 构造方法 public File(String pathname) public File(String parent, String child) public File(File parent, String child) 1.3 常用方法 1.3.1 获取 // 返回此File的绝对路径 public String getAbsolutePath() // 返回此File的创建时传入的path // toString就是调用getPath public String getPath() // 返回File表示文件或目录的名称 public String getName() // 返回File表示的文件长度，指向的文件大小， // 若为文件夹返回0；若文件不存在返回0 public long length() 1.3.2 判断 // 判断File表示的目录或文件是否存在 public boolean exists() // 判断是否为目录 public boolean isDirectory() // 判断是否为文件 public boolean isFile() 1.</description></item><item><title>java基础系列：函数编程</title><link>https://linjiasen63.github.io/posts/programming/java/java-se/functional.html</link><pubDate>Tue, 29 Dec 2020 23:16:42 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/java/java-se/functional.html</guid><description>1. Lambda表达式 从jdk8开始支持，条件如下：
必须具有接口，且接口中有仅仅有一个抽象方法 必须具有上下文推断 有且只有一个方法接口，称之为：函数式接口。
与匿名内部类的区别主要在于，编译后生成的文件。Lamada表达式不会生成class文件，而匿名内部类会。
public static void main(String[] args) { new Thread(() -&amp;gt; { System.out.println(&amp;#34;Hello world!&amp;#34;); }).start(); } 由以下组成：
一些参数 一个箭头 一段代码 标准格式：(参数列表) -&amp;gt; { 一些重写方法的代码 }
1.1 示例 public static void main(String[] args) { Integer[] arr = { 1, 2, 4, 3 }; Arrays.sort(arr, (Integer o1, Integer o2) -&amp;gt; { return o2 - o1; }); System.out.println(Arrays.toString(arr)); } 可推导，可省略。凡是根据上下文推导出来的内容都可以省略不写
括号中的参数列表的数据类型 括号中的参数列表只有一个，类型和()都可省略 如果{}中的代码只有一行，无论是否有返回值，都可以省略（{}，return, 分号），这三者需要一起省略。 public static void main(String[] args) { Integer[] arr = { 1, 2, 4, 3 }; Arrays.sort(arr, (o1, o2) -&amp;gt; o2 - o1); System.out.println(Arrays.toString(arr)); } 1.2 自定义函数式接口 // 使用注解可以进行校验 @FunctionalInterface public interface FuncInterface&amp;lt;T&amp;gt; { // 有且只有一个抽象方法，否则不是函数式接口 // 但可以有多个静态方法、默认方法、私有方法 public abstract T get(); } 2.</description></item><item><title>前端面试系列：浏览器输入url到网页展示期间发生了什么？</title><link>https://linjiasen63.github.io/posts/programming/front/interview/things-about-from-url-to-html.html</link><pubDate>Tue, 29 Dec 2020 14:42:56 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/front/interview/things-about-from-url-to-html.html</guid><description>1. 概要流程 DNS查找，确定地址 三次握手，建立链接 客户端发送请求 服务端返回响应 浏览器解析内容 2. 详细解释 2.1 DNS查找，确定地址 依次向浏览器、操作系统、路由器询问：是否知道域名对应的DNS地址，若知道则进行三次握手； 否则向本地local DNS服务器询问，若知道则进行三次握手； 否则向运营商DNS询问根DNS的地址，之后向根DNS，询问域名对应的服务商 2.2 三次握手，建立链接 2.3 客户端发送请求 2.4 服务端返回响应 2.5 浏览器解析内容</description></item><item><title>方便bash脚本开发的要点</title><link>https://linjiasen63.github.io/posts/programming/linux/bash-program-point.html</link><pubDate>Fri, 25 Dec 2020 16:43:35 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/linux/bash-program-point.html</guid><description>一、set命令 参考链接
# 执行脚本的时候，如果遇到不存在的变量，Bash 默认忽略它 #使用以下命令可改变默认行为：即遇到不存在的变量就会报错，并停止执行 set -u # 全写 set -o nounset # 默认情况下，脚本执行后，屏幕只显示运行结果，没有其他内容。如果多个命令连续执行，它们的运行结果就会连续输出。有时会分不清，某一段内容是什么命令产生的。 set -x # 全写 set -o xtrace # 如果脚本里面有运行失败的命令（返回值非0），Bash 默认会继续执行后面的命令。 # 使用以下命令可改变默认行为，即脚本只要发生错误，就终止执行。 set -e # 注意：不适用于管道命令，可使用以下命令处理。 # 全写 set -o errexit # 只要一个子命令失败，整个管道命令就失败，脚本就会终止执行 set -o pipefail # 管理中子命令失败，就退出 set -eo pipefail 总结 # 写法一 set -euxo pipefail # 写法二 set -eux set -o pipefail</description></item><item><title>java基础系列：语法进阶</title><link>https://linjiasen63.github.io/posts/programming/java/java-se/syntax-advance.html</link><pubDate>Thu, 24 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/java/java-se/syntax-advance.html</guid><description>1. 常用接口 1.1 系统内置 1.1.1 Object // 子类可重写以定制输出内容 Object.toString(); // 子类可重写以定制对象比较 Object.equals(); 1.1.2 Objects // 对两个对象进行比较，防止空指针异常 Objects.equals(变量a, 变量b); 1.1.3 System public static long currentTimeMillis()：返回此毫秒为单位的当前时间 public static void arraycopy(object src, int srcPos, object dest, int destPos, int length)：将数组中的指定数据拷贝到另一个数组中 1.2 时间转换 1.2.1 Date java.util.Date表示时间和日期的类，特定的瞬间，精确到毫秒（千分之一秒）
时间戳是指从标准基准时间（历元），即1970年1月1日00:00:00(GMT：英国格林威治)以来的毫秒数
// 获取从历元到当前系统时间的毫秒数 long timestamp = System.currentTimeMillis(); // 注意：中国（CST）属于东八区，会把时间增加8个小时，即历元为：1970年1月1日08:00:00 // 获取当前时间（当前时区） Date d1 = new Date(); // 获取从历元经过指定毫秒的时间 Date d2 = new Date(0L); // 将日期转换为毫秒 long timestamp1 = d1.getTime(); // 转换本地时间（已过期） System.out.println(d1.toLocalString()); 1.2.2 DateFormat java.text.DateFormat，是抽象类。按照指定模式，进行日期与文本之间的转换。
SimpleDateFormat dateFormat = new SimpleDateFormat(&amp;#34;yyyy-MM-dd HH:mm:ss&amp;#34;); // 格式化 String dateStr = dateFormat.format(date); System.out.println(dateStr); // 2020-12-24 00:09:59 // 解析：可能throw exception date = dateFormat.</description></item><item><title>idea常用快捷键</title><link>https://linjiasen63.github.io/posts/programming/java/idea-keymap.html</link><pubDate>Fri, 18 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/java/idea-keymap.html</guid><description> mac快捷键 win快捷键 具休功能描述 option + / alt + / 代码提示（自定义配置） option + enter alt + enter 自动导包、或声明变量（光标需停留在相应的类名上） command + X ctrl + Y 删除光标所在行 command + D ctrl + D 复制光标所在行，插入到光标位置下方 command + option + L ctrl + alt + L 格式化代码 command + / ctrl + / 单行注释，再按取消注释 command + shift + / ctrl + shift + / 注释选中代码，再按取消注释 command + N alt + ins 自动生成代码，如get、set等方法 option + shift + ↑或↓ alt + shift + ↑或↓ 向上或向下移动光标所在行 shift + F6 shift + F6 重命名</description></item><item><title>java基础系列：语法基础</title><link>https://linjiasen63.github.io/posts/programming/java/java-se/syntax-basic.html</link><pubDate>Wed, 16 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/java/java-se/syntax-basic.html</guid><description>1. 计算机通识 1.1 进制转换 辗转相除法（十进制转换为其它进制） 位权累加法（其它进制转换为十进制） 1.2 存储单位 1bit = 位（表示0或1） 1Byte = 8bit （数据存储的最小单元） 1KB = 1024Byte 1MB = 1024KB 1GB = 1024MB 1TB = 1024GB 1PB = 1024TB &amp;hellip; 1.3 Java简介 95年发布，已有20来年的历史。目前大部分公司使用的主要版本还是java8。
java编写的程序是跨平台的，但是JVM是非跨平台的（每种平台都有各自版本的JVM）
JDK = 编译器等开发工具 + JRE； JRE = 运行类库 + JVM； 1.3.1 DOS 盘符切换，如：D: (${磁盘标识}:) 切换目录 cd 清除 cls （全写：clear screen） 退出 exit 1.3.2 安装 配置JAVA_HOME 配置PATH mac下无需如此，开发配置简单。
1.3.3 jshell 从java9开始支持
# 进入 jshell # 退出 /exit 2. 基本语法 2.1 HelloWorld // public的类名必须与文件名大小写一致 public class HelloWorld { // 程序的执行入口 public static void main(String[] args) { System.</description></item><item><title>60min入门mysql</title><link>https://linjiasen63.github.io/posts/programming/mysql/tutorial-basic.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/mysql/tutorial-basic.html</guid><description>1. 基础知识 1.1 连接 # 连接mysql简写 # mysql -u${帐号名称} -p[${帐号密码}] mysql -uroot -p # 连接mysql全写 # mysql --user=${帐号名称} --password[=${帐号密码}] mysql --user=root --password # 指定mysql的ip 或 port # mysql [-h${服务器ip地址}] [-P${服务器端口}] -u${帐号名称} -p[${帐号密码}] mysql -h49.233.143.65 -P3306 -uroot -p 1.2 注释 -- 单行注释 # 单行注释 /* 块注释 */ 1.3 分类 DDL：数据定义语言。如定义数据库以及表结构等 DML：数据操作语言。如添加、创建、删除数据库以及表的记录等 DQL：数据查询语言。如查询数据库以及表的记录等 DCL：数据控制语言。如授权GRANK等 数据库使用相关语言。如USE ${数据库名称}; 或 show DATABASES;等语句 1.4 备份 1.4.1 命令行 -- 一、备份 -- mysqldump -u${帐号} -p${密码} ${数据库名} &amp;gt; ${备份文件的位置} -- 二、恢复 -- 1. 登录数据库管理系统 -- 2. 创建指定名称数据库 -- 3. 使用数据库 -- 4. 恢复数据 -- source ${备份文件的位置} 1.5 其它 -- 输出所有系统变量 show variables; 2. DDL 2.1 库的操作 2.</description></item><item><title>基于js的正则表达式入门教程</title><link>https://linjiasen63.github.io/posts/programming/regexp/tutorial-basic.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/regexp/tutorial-basic.html</guid><description>参考资料 正则极简教程，再也不会学了忘 # 结构：/pattern/flag # pattern = 模式 # flag = 标识符 1. 精确匹配（标识符） 标识符
i : 忽略大小写 g : 全局查找 m : 多行查找 u : 支持unicode 2. 横向模糊匹配 /p{m, n}/ * : { 0, } 匹配0个或多个 + : { 1, } 匹配1个或多个 ? : { 0, 1 } 匹配0个或1个 有两个含义：1. 惰性模式 2. 量词；区分方法：量词之后的?才表示惰性匹配 { m } : { m, m } 匹配m个 3. 纵向模糊匹配 // 匹配 apple或Apple /[aA]pple/ 3.1 简写形式 . 等价于 [^\n\r\u2018\u2029] \d 等价于 [0-9] \D 等价于 [^0-9] \w 等价于 [0-9a-zA-Z_] \W 等价于 [^0-9a-zA-Z_] \s 等价于 [\t\v\n\r\f]；表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符等。记忆方式：s是space character的首字母 \S 等价于 [^\t\v\n\r\f]；表示非空白字符 4. 位置 ^ : 文本开头 $ : 文本结尾 \b : 单词边界（一边是单词字符，一边是非单词字符） \B : 非单词边界（两边要不都是单词字符，要不都是非单词字符） (?</description></item><item><title>快速掌握Linux基本命令</title><link>https://linjiasen63.github.io/posts/programming/linux/bash-usage-basic.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/linux/bash-usage-basic.html</guid><description>1. 命令组成原则 # 命令名称 [-命令选项...] 命令参数 # 如 ls -l 2. 文件处理命令 2.1 目录命令 ls # -l --long的简写，展示具体信息 # -a --all的简写，展示所有内容 # -d 展示指定文件夹的信息 # -i 输出文件在系统中唯一的id信息 # -h 人性化输出（如将文件大小自动转换为KB、MB等） mkdir # 全称：make directories # -p 创建指定路径中不存在的目录 # 其中tmp目录不存在 mkdir -p ./tmp/200606 cd # 全称：change directories # cd 指定路径 cd .. cd /root cd ./tmp/200606 pwd # 全称：print working directories # 输出当前目录 pwd rmdir # 全称：remove empty directories # 删除空目录 rm # 全称：remove empty # 删除文件 # -r 删除目录 # -f 强制删除，不会二次询问 cp # -r 拷贝目录 cp -r ./tmp/200606 ./ mv # 移动与重命名 mv ./tmp/200606 ./2006 2.2 文件命令 # 退出：q touch、echo # touch 文件名 touch 1.</description></item><item><title>日常工作中关于Linux常用命令的汇总</title><link>https://linjiasen63.github.io/posts/programming/linux/job-bash-usage.html</link><pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate><guid>https://linjiasen63.github.io/posts/programming/linux/job-bash-usage.html</guid><description>1. 文件传输 参考链接
scp 本地复制到远程 远程复制到本地 两个远程之间复制 scp source&amp;lt;当前文件位置&amp;gt; destination&amp;lt;文件要复制到的位置&amp;gt;
远程文件位置的描述：${用户}@${ip地址或域名}:${文件的绝对路径}，如：root@linjiasen.com:/root/tmp/helloworld.txt
# 将远程服务器的文件 拷贝到本地 scp root@linjiasen.com:/root/tmp/helloworld.txt . # 如果没有配置免密，需要输入密码 拷贝文件夹 添加参数 -r
scp -r root@linjiasen.com:/root/tmp/ .</description></item></channel></rss>